import _classCallCheck from '@babel/runtime/helpers/classCallCheck';
import _createClass from '@babel/runtime/helpers/createClass';
import { Buffer } from 'buffer';
import { ed25519 } from '@noble/curves/ed25519';
import _asyncToGenerator from '@babel/runtime/helpers/asyncToGenerator';
import _inherits from '@babel/runtime/helpers/inherits';
import _possibleConstructorReturn from '@babel/runtime/helpers/possibleConstructorReturn';
import _getPrototypeOf from '@babel/runtime/helpers/getPrototypeOf';
import _regeneratorRuntime from '@babel/runtime/regenerator';
import BN from 'bn.js';
import bs58 from 'bs58';
import { sha256 } from '@noble/hashes/sha256';
import { serialize, deserialize, deserializeUnchecked } from 'borsh';
import * as BufferLayout from '@solana/buffer-layout';
import { blob } from '@solana/buffer-layout';
import _slicedToArray from '@babel/runtime/helpers/slicedToArray';
import { toBigIntLE, toBufferLE } from 'bigint-buffer';
import _defineProperty from '@babel/runtime/helpers/defineProperty';
import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';
import _typeof from '@babel/runtime/helpers/typeof';
import _objectWithoutProperties from '@babel/runtime/helpers/objectWithoutProperties';
import { coerce, instance, string, tuple, literal, unknown, type, number, array, nullable, optional, boolean, record, union, create, any, assert as assert$1 } from 'superstruct';
import RpcClient from 'jayson/lib/client/browser';
import _wrapNativeSuper from '@babel/runtime/helpers/wrapNativeSuper';
import _get from '@babel/runtime/helpers/get';
import RpcWebSocketCommonClient from 'rpc-websockets/dist/lib/client';
import createRpc from 'rpc-websockets/dist/lib/client/websocket.browser';
import { keccak_256 } from '@noble/hashes/sha3';
import { secp256k1 } from '@noble/curves/secp256k1';

/**
 * A 64 byte secret key, the first 32 bytes of which is the
 * private scalar and the last 32 bytes is the public key.
 * Read more: https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/
 */

/**
 * Ed25519 Keypair
 */

var generatePrivateKey = ed25519.utils.randomPrivateKey;
var generateKeypair = function generateKeypair() {
  var privateScalar = ed25519.utils.randomPrivateKey();
  var publicKey = getPublicKey(privateScalar);
  var secretKey = new Uint8Array(64);
  secretKey.set(privateScalar);
  secretKey.set(publicKey, 32);
  return {
    publicKey: publicKey,
    secretKey: secretKey
  };
};
var getPublicKey = ed25519.getPublicKey;
function isOnCurve(publicKey) {
  try {
    ed25519.ExtendedPoint.fromHex(publicKey);
    return true;
  } catch (_unused) {
    return false;
  }
}
var sign = function sign(message, secretKey) {
  return ed25519.sign(message, secretKey.slice(0, 32));
};
var verify = ed25519.verify;

var toBuffer = function toBuffer(arr) {
  if (Buffer.isBuffer(arr)) {
    return arr;
  } else if (arr instanceof Uint8Array) {
    return Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);
  } else {
    return Buffer.from(arr);
  }
};

function _createSuper$4(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$4(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct$4() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

// Class wrapping a plain object
var Struct = /*#__PURE__*/function () {
  function Struct(properties) {
    _classCallCheck(this, Struct);
    Object.assign(this, properties);
  }
  _createClass(Struct, [{
    key: "encode",
    value: function encode() {
      return Buffer.from(serialize(SOLANA_SCHEMA, this));
    }
  }], [{
    key: "decode",
    value: function decode(data) {
      return deserialize(SOLANA_SCHEMA, this, data);
    }
  }, {
    key: "decodeUnchecked",
    value: function decodeUnchecked(data) {
      return deserializeUnchecked(SOLANA_SCHEMA, this, data);
    }
  }]);
  return Struct;
}();

// Class representing a Rust-compatible enum, since enums are only strings or
// numbers in pure JS
var Enum = /*#__PURE__*/function (_Struct) {
  _inherits(Enum, _Struct);
  var _super = _createSuper$4(Enum);
  function Enum(properties) {
    var _this;
    _classCallCheck(this, Enum);
    _this = _super.call(this, properties);
    _this["enum"] = '';
    if (Object.keys(properties).length !== 1) {
      throw new Error('Enum can only take single value');
    }
    Object.keys(properties).map(function (key) {
      _this["enum"] = key;
    });
    return _this;
  }
  return _createClass(Enum);
}(Struct);
var SOLANA_SCHEMA = new Map();

var _Symbol$toStringTag;
function _createSuper$3(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$3(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct$3() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Maximum length of derived pubkey seed
 */
var MAX_SEED_LENGTH = 32;

/**
 * Size of public key in bytes
 */
var PUBLIC_KEY_LENGTH = 32;

/**
 * Value to be converted into public key
 */

/**
 * JSON object representation of PublicKey class
 */

function isPublicKeyData(value) {
  return value._bn !== undefined;
}

// local counter used by PublicKey.unique()
var uniquePublicKeyCounter = 1;

/**
 * A public key
 */
_Symbol$toStringTag = Symbol.toStringTag;
var PublicKey = /*#__PURE__*/function (_Struct) {
  _inherits(PublicKey, _Struct);
  var _super = _createSuper$3(PublicKey);
  /**
   * Create a new PublicKey object
   * @param value ed25519 public key as buffer or base-58 encoded string
   */
  function PublicKey(value) {
    var _this;
    _classCallCheck(this, PublicKey);
    _this = _super.call(this, {});
    /** @internal */
    _this._bn = void 0;
    if (isPublicKeyData(value)) {
      _this._bn = value._bn;
    } else {
      if (typeof value === 'string') {
        // assume base 58 encoding by default
        var decoded = bs58.decode(value);
        if (decoded.length != PUBLIC_KEY_LENGTH) {
          throw new Error("Invalid public key input");
        }
        _this._bn = new BN(decoded);
      } else {
        _this._bn = new BN(value);
      }
      if (_this._bn.byteLength() > PUBLIC_KEY_LENGTH) {
        throw new Error("Invalid public key input");
      }
    }
    return _this;
  }

  /**
   * Returns a unique PublicKey for tests and benchmarks using a counter
   */
  _createClass(PublicKey, [{
    key: "equals",
    value:
    /**
     * Checks if two publicKeys are equal
     */
    function equals(publicKey) {
      return this._bn.eq(publicKey._bn);
    }

    /**
     * Return the base-58 representation of the public key
     */
  }, {
    key: "toBase58",
    value: function toBase58() {
      return bs58.encode(this.toBytes());
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.toBase58();
    }

    /**
     * Return the byte array representation of the public key in big endian
     */
  }, {
    key: "toBytes",
    value: function toBytes() {
      var buf = this.toBuffer();
      return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
    }

    /**
     * Return the Buffer representation of the public key in big endian
     */
  }, {
    key: "toBuffer",
    value: function toBuffer() {
      var b = this._bn.toArrayLike(Buffer);
      if (b.length === PUBLIC_KEY_LENGTH) {
        return b;
      }
      var zeroPad = Buffer.alloc(32);
      b.copy(zeroPad, 32 - b.length);
      return zeroPad;
    }
  }, {
    key: _Symbol$toStringTag,
    get: function get() {
      return "PublicKey(".concat(this.toString(), ")");
    }

    /**
     * Return the base-58 representation of the public key
     */
  }, {
    key: "toString",
    value: function toString() {
      return this.toBase58();
    }

    /**
     * Derive a public key from another key, a seed, and a program ID.
     * The program ID will also serve as the owner of the public key, giving
     * it permission to write data to the account.
     */
    /* eslint-disable require-await */
  }], [{
    key: "unique",
    value: function unique() {
      var key = new PublicKey(uniquePublicKeyCounter);
      uniquePublicKeyCounter += 1;
      return new PublicKey(key.toBuffer());
    }

    /**
     * Default public key value. The base58-encoded string representation is all ones (as seen below)
     * The underlying BN number is 32 bytes that are all zeros
     */
  }, {
    key: "createWithSeed",
    value: function () {
      var _createWithSeed = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(fromPublicKey, seed, programId) {
        var buffer, publicKeyBytes;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              buffer = Buffer.concat([fromPublicKey.toBuffer(), Buffer.from(seed), programId.toBuffer()]);
              publicKeyBytes = sha256(buffer);
              return _context.abrupt("return", new PublicKey(publicKeyBytes));
            case 3:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      function createWithSeed(_x, _x2, _x3) {
        return _createWithSeed.apply(this, arguments);
      }
      return createWithSeed;
    }()
    /**
     * Derive a program address from seeds and a program ID.
     */
    /* eslint-disable require-await */
  }, {
    key: "createProgramAddressSync",
    value: function createProgramAddressSync(seeds, programId) {
      var buffer = Buffer.alloc(0);
      seeds.forEach(function (seed) {
        if (seed.length > MAX_SEED_LENGTH) {
          throw new TypeError("Max seed length exceeded");
        }
        buffer = Buffer.concat([buffer, toBuffer(seed)]);
      });
      buffer = Buffer.concat([buffer, programId.toBuffer(), Buffer.from('ProgramDerivedAddress')]);
      var publicKeyBytes = sha256(buffer);
      if (isOnCurve(publicKeyBytes)) {
        throw new Error("Invalid seeds, address must fall off the curve");
      }
      return new PublicKey(publicKeyBytes);
    }

    /**
     * Async version of createProgramAddressSync
     * For backwards compatibility
     *
     * @deprecated Use {@link createProgramAddressSync} instead
     */
    /* eslint-disable require-await */
  }, {
    key: "createProgramAddress",
    value: function () {
      var _createProgramAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(seeds, programId) {
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.abrupt("return", this.createProgramAddressSync(seeds, programId));
            case 1:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function createProgramAddress(_x4, _x5) {
        return _createProgramAddress.apply(this, arguments);
      }
      return createProgramAddress;
    }()
    /**
     * Find a valid program address
     *
     * Valid program addresses must fall off the ed25519 curve.  This function
     * iterates a nonce until it finds one that when combined with the seeds
     * results in a valid program address.
     */
  }, {
    key: "findProgramAddressSync",
    value: function findProgramAddressSync(seeds, programId) {
      var nonce = 255;
      var address;
      while (nonce != 0) {
        try {
          var seedsWithNonce = seeds.concat(Buffer.from([nonce]));
          address = this.createProgramAddressSync(seedsWithNonce, programId);
        } catch (err) {
          if (err instanceof TypeError) {
            throw err;
          }
          nonce--;
          continue;
        }
        return [address, nonce];
      }
      throw new Error("Unable to find a viable program address nonce");
    }

    /**
     * Async version of findProgramAddressSync
     * For backwards compatibility
     *
     * @deprecated Use {@link findProgramAddressSync} instead
     */
  }, {
    key: "findProgramAddress",
    value: function () {
      var _findProgramAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(seeds, programId) {
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              return _context3.abrupt("return", this.findProgramAddressSync(seeds, programId));
            case 1:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function findProgramAddress(_x6, _x7) {
        return _findProgramAddress.apply(this, arguments);
      }
      return findProgramAddress;
    }()
    /**
     * Check that a pubkey is on the ed25519 curve.
     */
  }, {
    key: "isOnCurve",
    value: function isOnCurve$1(pubkeyData) {
      var pubkey = new PublicKey(pubkeyData);
      return isOnCurve(pubkey.toBytes());
    }
  }]);
  return PublicKey;
}(Struct);
PublicKey["default"] = new PublicKey('11111111111111111111111111111111');
SOLANA_SCHEMA.set(PublicKey, {
  kind: 'struct',
  fields: [['_bn', 'u256']]
});

/**
 * An account key pair (public and secret keys).
 *
 * @deprecated since v1.10.0, please use {@link Keypair} instead.
 */
var Account = /*#__PURE__*/function () {
  /**
   * Create a new Account object
   *
   * If the secretKey parameter is not provided a new key pair is randomly
   * created for the account
   *
   * @param secretKey Secret key for the account
   */
  function Account(secretKey) {
    _classCallCheck(this, Account);
    /** @internal */
    this._publicKey = void 0;
    /** @internal */
    this._secretKey = void 0;
    if (secretKey) {
      var secretKeyBuffer = toBuffer(secretKey);
      if (secretKey.length !== 64) {
        throw new Error('bad secret key size');
      }
      this._publicKey = secretKeyBuffer.slice(32, 64);
      this._secretKey = secretKeyBuffer.slice(0, 32);
    } else {
      this._secretKey = toBuffer(generatePrivateKey());
      this._publicKey = toBuffer(getPublicKey(this._secretKey));
    }
  }

  /**
   * The public key for this account
   */
  _createClass(Account, [{
    key: "publicKey",
    get: function get() {
      return new PublicKey(this._publicKey);
    }

    /**
     * The **unencrypted** secret key for this account. The first 32 bytes
     * is the private scalar and the last 32 bytes is the public key.
     * Read more: https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/
     */
  }, {
    key: "secretKey",
    get: function get() {
      return Buffer.concat([this._secretKey, this._publicKey], 64);
    }
  }]);
  return Account;
}();

var BPF_LOADER_DEPRECATED_PROGRAM_ID = new PublicKey('BPFLoader1111111111111111111111111111111111');

/**
 * Maximum over-the-wire size of a Transaction
 *
 * 1280 is IPv6 minimum MTU
 * 40 bytes is the size of the IPv6 header
 * 8 bytes is the size of the fragment header
 */
var PACKET_DATA_SIZE = 1280 - 40 - 8;
var VERSION_PREFIX_MASK = 0x7f;
var SIGNATURE_LENGTH_IN_BYTES = 64;

function _createSuper$2(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$2(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct$2() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var TransactionExpiredBlockheightExceededError = /*#__PURE__*/function (_Error) {
  _inherits(TransactionExpiredBlockheightExceededError, _Error);
  var _super = _createSuper$2(TransactionExpiredBlockheightExceededError);
  function TransactionExpiredBlockheightExceededError(signature) {
    var _this;
    _classCallCheck(this, TransactionExpiredBlockheightExceededError);
    _this = _super.call(this, "Signature ".concat(signature, " has expired: block height exceeded."));
    _this.signature = void 0;
    _this.signature = signature;
    return _this;
  }
  return _createClass(TransactionExpiredBlockheightExceededError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
Object.defineProperty(TransactionExpiredBlockheightExceededError.prototype, 'name', {
  value: 'TransactionExpiredBlockheightExceededError'
});
var TransactionExpiredTimeoutError = /*#__PURE__*/function (_Error2) {
  _inherits(TransactionExpiredTimeoutError, _Error2);
  var _super2 = _createSuper$2(TransactionExpiredTimeoutError);
  function TransactionExpiredTimeoutError(signature, timeoutSeconds) {
    var _this2;
    _classCallCheck(this, TransactionExpiredTimeoutError);
    _this2 = _super2.call(this, "Transaction was not confirmed in ".concat(timeoutSeconds.toFixed(2), " seconds. It is ") + 'unknown if it succeeded or failed. Check signature ' + "".concat(signature, " using the Solana Explorer or CLI tools."));
    _this2.signature = void 0;
    _this2.signature = signature;
    return _this2;
  }
  return _createClass(TransactionExpiredTimeoutError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
Object.defineProperty(TransactionExpiredTimeoutError.prototype, 'name', {
  value: 'TransactionExpiredTimeoutError'
});
var TransactionExpiredNonceInvalidError = /*#__PURE__*/function (_Error3) {
  _inherits(TransactionExpiredNonceInvalidError, _Error3);
  var _super3 = _createSuper$2(TransactionExpiredNonceInvalidError);
  function TransactionExpiredNonceInvalidError(signature) {
    var _this3;
    _classCallCheck(this, TransactionExpiredNonceInvalidError);
    _this3 = _super3.call(this, "Signature ".concat(signature, " has expired: the nonce is no longer valid."));
    _this3.signature = void 0;
    _this3.signature = signature;
    return _this3;
  }
  return _createClass(TransactionExpiredNonceInvalidError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
Object.defineProperty(TransactionExpiredNonceInvalidError.prototype, 'name', {
  value: 'TransactionExpiredNonceInvalidError'
});

function _createForOfIteratorHelper$5(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$5(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray$5(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$5(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$5(o, minLen); }
function _arrayLikeToArray$5(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
var MessageAccountKeys = /*#__PURE__*/function () {
  function MessageAccountKeys(staticAccountKeys, accountKeysFromLookups) {
    _classCallCheck(this, MessageAccountKeys);
    this.staticAccountKeys = void 0;
    this.accountKeysFromLookups = void 0;
    this.staticAccountKeys = staticAccountKeys;
    this.accountKeysFromLookups = accountKeysFromLookups;
  }
  _createClass(MessageAccountKeys, [{
    key: "keySegments",
    value: function keySegments() {
      var keySegments = [this.staticAccountKeys];
      if (this.accountKeysFromLookups) {
        keySegments.push(this.accountKeysFromLookups.writable);
        keySegments.push(this.accountKeysFromLookups.readonly);
      }
      return keySegments;
    }
  }, {
    key: "get",
    value: function get(index) {
      var _iterator = _createForOfIteratorHelper$5(this.keySegments()),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var keySegment = _step.value;
          if (index < keySegment.length) {
            return keySegment[index];
          } else {
            index -= keySegment.length;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return;
    }
  }, {
    key: "length",
    get: function get() {
      return this.keySegments().flat().length;
    }
  }, {
    key: "compileInstructions",
    value: function compileInstructions(instructions) {
      // Bail early if any account indexes would overflow a u8
      var U8_MAX = 255;
      if (this.length > U8_MAX + 1) {
        throw new Error('Account index overflow encountered during compilation');
      }
      var keyIndexMap = new Map();
      this.keySegments().flat().forEach(function (key, index) {
        keyIndexMap.set(key.toBase58(), index);
      });
      var findKeyIndex = function findKeyIndex(key) {
        var keyIndex = keyIndexMap.get(key.toBase58());
        if (keyIndex === undefined) throw new Error('Encountered an unknown instruction account key during compilation');
        return keyIndex;
      };
      return instructions.map(function (instruction) {
        return {
          programIdIndex: findKeyIndex(instruction.programId),
          accountKeyIndexes: instruction.keys.map(function (meta) {
            return findKeyIndex(meta.pubkey);
          }),
          data: instruction.data
        };
      });
    }
  }]);
  return MessageAccountKeys;
}();

/**
 * Layout for a public key
 */
var publicKey = function publicKey() {
  var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'publicKey';
  return BufferLayout.blob(32, property);
};

/**
 * Layout for a signature
 */
var signature = function signature() {
  var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'signature';
  return BufferLayout.blob(64, property);
};
/**
 * Layout for a Rust String type
 */
var rustString = function rustString() {
  var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'string';
  var rsl = BufferLayout.struct([BufferLayout.u32('length'), BufferLayout.u32('lengthPadding'), BufferLayout.blob(BufferLayout.offset(BufferLayout.u32(), -8), 'chars')], property);
  var _decode = rsl.decode.bind(rsl);
  var _encode = rsl.encode.bind(rsl);
  var rslShim = rsl;
  rslShim.decode = function (b, offset) {
    var data = _decode(b, offset);
    return data['chars'].toString();
  };
  rslShim.encode = function (str, b, offset) {
    var data = {
      chars: Buffer.from(str, 'utf8')
    };
    return _encode(data, b, offset);
  };
  rslShim.alloc = function (str) {
    return BufferLayout.u32().span + BufferLayout.u32().span + Buffer.from(str, 'utf8').length;
  };
  return rslShim;
};

/**
 * Layout for an Authorized object
 */
var authorized = function authorized() {
  var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'authorized';
  return BufferLayout.struct([publicKey('staker'), publicKey('withdrawer')], property);
};

/**
 * Layout for a Lockup object
 */
var lockup = function lockup() {
  var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'lockup';
  return BufferLayout.struct([BufferLayout.ns64('unixTimestamp'), BufferLayout.ns64('epoch'), publicKey('custodian')], property);
};

/**
 *  Layout for a VoteInit object
 */
var voteInit = function voteInit() {
  var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'voteInit';
  return BufferLayout.struct([publicKey('nodePubkey'), publicKey('authorizedVoter'), publicKey('authorizedWithdrawer'), BufferLayout.u8('commission')], property);
};

/**
 *  Layout for a VoteAuthorizeWithSeedArgs object
 */
var voteAuthorizeWithSeedArgs = function voteAuthorizeWithSeedArgs() {
  var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'voteAuthorizeWithSeedArgs';
  return BufferLayout.struct([BufferLayout.u32('voteAuthorizationType'), publicKey('currentAuthorityDerivedKeyOwnerPubkey'), rustString('currentAuthorityDerivedKeySeed'), publicKey('newAuthorized')], property);
};
function getAlloc(type, fields) {
  var getItemAlloc = function getItemAlloc(item) {
    if (item.span >= 0) {
      return item.span;
    } else if (typeof item.alloc === 'function') {
      return item.alloc(fields[item.property]);
    } else if ('count' in item && 'elementLayout' in item) {
      var field = fields[item.property];
      if (Array.isArray(field)) {
        return field.length * getItemAlloc(item.elementLayout);
      }
    } else if ('fields' in item) {
      // This is a `Structure` whose size needs to be recursively measured.
      return getAlloc({
        layout: item
      }, fields[item.property]);
    }
    // Couldn't determine allocated size of layout
    return 0;
  };
  var alloc = 0;
  type.layout.fields.forEach(function (item) {
    alloc += getItemAlloc(item);
  });
  return alloc;
}

function decodeLength(bytes) {
  var len = 0;
  var size = 0;
  for (;;) {
    var elem = bytes.shift();
    len |= (elem & 0x7f) << size * 7;
    size += 1;
    if ((elem & 0x80) === 0) {
      break;
    }
  }
  return len;
}
function encodeLength(bytes, len) {
  var rem_len = len;
  for (;;) {
    var elem = rem_len & 0x7f;
    rem_len >>= 7;
    if (rem_len == 0) {
      bytes.push(elem);
      break;
    } else {
      elem |= 0x80;
      bytes.push(elem);
    }
  }
}

function assert (condition, message) {
  if (!condition) {
    throw new Error(message || 'Assertion failed');
  }
}

function _createForOfIteratorHelper$4(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$4(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray$4(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$4(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$4(o, minLen); }
function _arrayLikeToArray$4(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
var CompiledKeys = /*#__PURE__*/function () {
  function CompiledKeys(payer, keyMetaMap) {
    _classCallCheck(this, CompiledKeys);
    this.payer = void 0;
    this.keyMetaMap = void 0;
    this.payer = payer;
    this.keyMetaMap = keyMetaMap;
  }
  _createClass(CompiledKeys, [{
    key: "getMessageComponents",
    value: function getMessageComponents() {
      var mapEntries = _toConsumableArray(this.keyMetaMap.entries());
      assert(mapEntries.length <= 256, 'Max static account keys length exceeded');
      var writableSigners = mapEntries.filter(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
          meta = _ref2[1];
        return meta.isSigner && meta.isWritable;
      });
      var readonlySigners = mapEntries.filter(function (_ref3) {
        var _ref4 = _slicedToArray(_ref3, 2),
          meta = _ref4[1];
        return meta.isSigner && !meta.isWritable;
      });
      var writableNonSigners = mapEntries.filter(function (_ref5) {
        var _ref6 = _slicedToArray(_ref5, 2),
          meta = _ref6[1];
        return !meta.isSigner && meta.isWritable;
      });
      var readonlyNonSigners = mapEntries.filter(function (_ref7) {
        var _ref8 = _slicedToArray(_ref7, 2),
          meta = _ref8[1];
        return !meta.isSigner && !meta.isWritable;
      });
      var header = {
        numRequiredSignatures: writableSigners.length + readonlySigners.length,
        numReadonlySignedAccounts: readonlySigners.length,
        numReadonlyUnsignedAccounts: readonlyNonSigners.length
      };

      // sanity checks
      {
        assert(writableSigners.length > 0, 'Expected at least one writable signer key');
        var _writableSigners$ = _slicedToArray(writableSigners[0], 1),
          payerAddress = _writableSigners$[0];
        assert(payerAddress === this.payer.toBase58(), 'Expected first writable signer key to be the fee payer');
      }
      var staticAccountKeys = [].concat(_toConsumableArray(writableSigners.map(function (_ref9) {
        var _ref10 = _slicedToArray(_ref9, 1),
          address = _ref10[0];
        return new PublicKey(address);
      })), _toConsumableArray(readonlySigners.map(function (_ref11) {
        var _ref12 = _slicedToArray(_ref11, 1),
          address = _ref12[0];
        return new PublicKey(address);
      })), _toConsumableArray(writableNonSigners.map(function (_ref13) {
        var _ref14 = _slicedToArray(_ref13, 1),
          address = _ref14[0];
        return new PublicKey(address);
      })), _toConsumableArray(readonlyNonSigners.map(function (_ref15) {
        var _ref16 = _slicedToArray(_ref15, 1),
          address = _ref16[0];
        return new PublicKey(address);
      })));
      return [header, staticAccountKeys];
    }
  }, {
    key: "extractTableLookup",
    value: function extractTableLookup(lookupTable) {
      var _this$drainKeysFoundI = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, function (keyMeta) {
          return !keyMeta.isSigner && !keyMeta.isInvoked && keyMeta.isWritable;
        }),
        _this$drainKeysFoundI2 = _slicedToArray(_this$drainKeysFoundI, 2),
        writableIndexes = _this$drainKeysFoundI2[0],
        drainedWritableKeys = _this$drainKeysFoundI2[1];
      var _this$drainKeysFoundI3 = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, function (keyMeta) {
          return !keyMeta.isSigner && !keyMeta.isInvoked && !keyMeta.isWritable;
        }),
        _this$drainKeysFoundI4 = _slicedToArray(_this$drainKeysFoundI3, 2),
        readonlyIndexes = _this$drainKeysFoundI4[0],
        drainedReadonlyKeys = _this$drainKeysFoundI4[1];

      // Don't extract lookup if no keys were found
      if (writableIndexes.length === 0 && readonlyIndexes.length === 0) {
        return;
      }
      return [{
        accountKey: lookupTable.key,
        writableIndexes: writableIndexes,
        readonlyIndexes: readonlyIndexes
      }, {
        writable: drainedWritableKeys,
        readonly: drainedReadonlyKeys
      }];
    }

    /** @internal */
  }, {
    key: "drainKeysFoundInLookupTable",
    value: function drainKeysFoundInLookupTable(lookupTableEntries, keyMetaFilter) {
      var _this = this;
      var lookupTableIndexes = new Array();
      var drainedKeys = new Array();
      var _iterator = _createForOfIteratorHelper$4(this.keyMetaMap.entries()),
        _step;
      try {
        var _loop = function _loop() {
          var _step$value = _slicedToArray(_step.value, 2),
            address = _step$value[0],
            keyMeta = _step$value[1];
          if (keyMetaFilter(keyMeta)) {
            var key = new PublicKey(address);
            var lookupTableIndex = lookupTableEntries.findIndex(function (entry) {
              return entry.equals(key);
            });
            if (lookupTableIndex >= 0) {
              assert(lookupTableIndex < 256, 'Max lookup table index exceeded');
              lookupTableIndexes.push(lookupTableIndex);
              drainedKeys.push(key);
              _this.keyMetaMap["delete"](address);
            }
          }
        };
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          _loop();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return [lookupTableIndexes, drainedKeys];
    }
  }], [{
    key: "compile",
    value: function compile(instructions, payer) {
      var keyMetaMap = new Map();
      var getOrInsertDefault = function getOrInsertDefault(pubkey) {
        var address = pubkey.toBase58();
        var keyMeta = keyMetaMap.get(address);
        if (keyMeta === undefined) {
          keyMeta = {
            isSigner: false,
            isWritable: false,
            isInvoked: false
          };
          keyMetaMap.set(address, keyMeta);
        }
        return keyMeta;
      };
      var payerKeyMeta = getOrInsertDefault(payer);
      payerKeyMeta.isSigner = true;
      payerKeyMeta.isWritable = true;
      var _iterator2 = _createForOfIteratorHelper$4(instructions),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var ix = _step2.value;
          getOrInsertDefault(ix.programId).isInvoked = true;
          var _iterator3 = _createForOfIteratorHelper$4(ix.keys),
            _step3;
          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var accountMeta = _step3.value;
              var _keyMeta = getOrInsertDefault(accountMeta.pubkey);
              _keyMeta.isSigner || (_keyMeta.isSigner = accountMeta.isSigner);
              _keyMeta.isWritable || (_keyMeta.isWritable = accountMeta.isWritable);
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      return new CompiledKeys(payer, keyMetaMap);
    }
  }]);
  return CompiledKeys;
}();

/**
 * An instruction to execute by a program
 *
 * @property {number} programIdIndex
 * @property {number[]} accounts
 * @property {string} data
 */

/**
 * Message constructor arguments
 */

/**
 * List of instructions to be processed atomically
 */
var Message = /*#__PURE__*/function () {
  function Message(args) {
    var _this = this;
    _classCallCheck(this, Message);
    this.header = void 0;
    this.accountKeys = void 0;
    this.recentBlockhash = void 0;
    this.instructions = void 0;
    this.indexToProgramIds = new Map();
    this.header = args.header;
    this.accountKeys = args.accountKeys.map(function (account) {
      return new PublicKey(account);
    });
    this.recentBlockhash = args.recentBlockhash;
    this.instructions = args.instructions;
    this.instructions.forEach(function (ix) {
      return _this.indexToProgramIds.set(ix.programIdIndex, _this.accountKeys[ix.programIdIndex]);
    });
  }
  _createClass(Message, [{
    key: "version",
    get: function get() {
      return 'legacy';
    }
  }, {
    key: "staticAccountKeys",
    get: function get() {
      return this.accountKeys;
    }
  }, {
    key: "compiledInstructions",
    get: function get() {
      return this.instructions.map(function (ix) {
        return {
          programIdIndex: ix.programIdIndex,
          accountKeyIndexes: ix.accounts,
          data: bs58.decode(ix.data)
        };
      });
    }
  }, {
    key: "addressTableLookups",
    get: function get() {
      return [];
    }
  }, {
    key: "getAccountKeys",
    value: function getAccountKeys() {
      return new MessageAccountKeys(this.staticAccountKeys);
    }
  }, {
    key: "isAccountSigner",
    value: function isAccountSigner(index) {
      return index < this.header.numRequiredSignatures;
    }
  }, {
    key: "isAccountWritable",
    value: function isAccountWritable(index) {
      var numSignedAccounts = this.header.numRequiredSignatures;
      if (index >= this.header.numRequiredSignatures) {
        var unsignedAccountIndex = index - numSignedAccounts;
        var numUnsignedAccounts = this.accountKeys.length - numSignedAccounts;
        var numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;
        return unsignedAccountIndex < numWritableUnsignedAccounts;
      } else {
        var numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;
        return index < numWritableSignedAccounts;
      }
    }
  }, {
    key: "isProgramId",
    value: function isProgramId(index) {
      return this.indexToProgramIds.has(index);
    }
  }, {
    key: "programIds",
    value: function programIds() {
      return _toConsumableArray(this.indexToProgramIds.values());
    }
  }, {
    key: "nonProgramIds",
    value: function nonProgramIds() {
      var _this2 = this;
      return this.accountKeys.filter(function (_, index) {
        return !_this2.isProgramId(index);
      });
    }
  }, {
    key: "serialize",
    value: function serialize() {
      var numKeys = this.accountKeys.length;
      var keyCount = [];
      encodeLength(keyCount, numKeys);
      var instructions = this.instructions.map(function (instruction) {
        var accounts = instruction.accounts,
          programIdIndex = instruction.programIdIndex;
        var data = Array.from(bs58.decode(instruction.data));
        var keyIndicesCount = [];
        encodeLength(keyIndicesCount, accounts.length);
        var dataCount = [];
        encodeLength(dataCount, data.length);
        return {
          programIdIndex: programIdIndex,
          keyIndicesCount: Buffer.from(keyIndicesCount),
          keyIndices: accounts,
          dataLength: Buffer.from(dataCount),
          data: data
        };
      });
      var instructionCount = [];
      encodeLength(instructionCount, instructions.length);
      var instructionBuffer = Buffer.alloc(PACKET_DATA_SIZE);
      Buffer.from(instructionCount).copy(instructionBuffer);
      var instructionBufferLength = instructionCount.length;
      instructions.forEach(function (instruction) {
        var instructionLayout = BufferLayout.struct([BufferLayout.u8('programIdIndex'), BufferLayout.blob(instruction.keyIndicesCount.length, 'keyIndicesCount'), BufferLayout.seq(BufferLayout.u8('keyIndex'), instruction.keyIndices.length, 'keyIndices'), BufferLayout.blob(instruction.dataLength.length, 'dataLength'), BufferLayout.seq(BufferLayout.u8('userdatum'), instruction.data.length, 'data')]);
        var length = instructionLayout.encode(instruction, instructionBuffer, instructionBufferLength);
        instructionBufferLength += length;
      });
      instructionBuffer = instructionBuffer.slice(0, instructionBufferLength);
      var signDataLayout = BufferLayout.struct([BufferLayout.blob(1, 'numRequiredSignatures'), BufferLayout.blob(1, 'numReadonlySignedAccounts'), BufferLayout.blob(1, 'numReadonlyUnsignedAccounts'), BufferLayout.blob(keyCount.length, 'keyCount'), BufferLayout.seq(publicKey('key'), numKeys, 'keys'), publicKey('recentBlockhash')]);
      var transaction = {
        numRequiredSignatures: Buffer.from([this.header.numRequiredSignatures]),
        numReadonlySignedAccounts: Buffer.from([this.header.numReadonlySignedAccounts]),
        numReadonlyUnsignedAccounts: Buffer.from([this.header.numReadonlyUnsignedAccounts]),
        keyCount: Buffer.from(keyCount),
        keys: this.accountKeys.map(function (key) {
          return toBuffer(key.toBytes());
        }),
        recentBlockhash: bs58.decode(this.recentBlockhash)
      };
      var signData = Buffer.alloc(2048);
      var length = signDataLayout.encode(transaction, signData);
      instructionBuffer.copy(signData, length);
      return signData.slice(0, length + instructionBuffer.length);
    }

    /**
     * Decode a compiled message into a Message object.
     */
  }], [{
    key: "compile",
    value: function compile(args) {
      var compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);
      var _compiledKeys$getMess = compiledKeys.getMessageComponents(),
        _compiledKeys$getMess2 = _slicedToArray(_compiledKeys$getMess, 2),
        header = _compiledKeys$getMess2[0],
        staticAccountKeys = _compiledKeys$getMess2[1];
      var accountKeys = new MessageAccountKeys(staticAccountKeys);
      var instructions = accountKeys.compileInstructions(args.instructions).map(function (ix) {
        return {
          programIdIndex: ix.programIdIndex,
          accounts: ix.accountKeyIndexes,
          data: bs58.encode(ix.data)
        };
      });
      return new Message({
        header: header,
        accountKeys: staticAccountKeys,
        recentBlockhash: args.recentBlockhash,
        instructions: instructions
      });
    }
  }, {
    key: "from",
    value: function from(buffer) {
      // Slice up wire data
      var byteArray = _toConsumableArray(buffer);
      var numRequiredSignatures = byteArray.shift();
      if (numRequiredSignatures !== (numRequiredSignatures & VERSION_PREFIX_MASK)) {
        throw new Error('Versioned messages must be deserialized with VersionedMessage.deserialize()');
      }
      var numReadonlySignedAccounts = byteArray.shift();
      var numReadonlyUnsignedAccounts = byteArray.shift();
      var accountCount = decodeLength(byteArray);
      var accountKeys = [];
      for (var i = 0; i < accountCount; i++) {
        var account = byteArray.slice(0, PUBLIC_KEY_LENGTH);
        byteArray = byteArray.slice(PUBLIC_KEY_LENGTH);
        accountKeys.push(new PublicKey(Buffer.from(account)));
      }
      var recentBlockhash = byteArray.slice(0, PUBLIC_KEY_LENGTH);
      byteArray = byteArray.slice(PUBLIC_KEY_LENGTH);
      var instructionCount = decodeLength(byteArray);
      var instructions = [];
      for (var _i = 0; _i < instructionCount; _i++) {
        var programIdIndex = byteArray.shift();
        var _accountCount = decodeLength(byteArray);
        var accounts = byteArray.slice(0, _accountCount);
        byteArray = byteArray.slice(_accountCount);
        var dataLength = decodeLength(byteArray);
        var dataSlice = byteArray.slice(0, dataLength);
        var data = bs58.encode(Buffer.from(dataSlice));
        byteArray = byteArray.slice(dataLength);
        instructions.push({
          programIdIndex: programIdIndex,
          accounts: accounts,
          data: data
        });
      }
      var messageArgs = {
        header: {
          numRequiredSignatures: numRequiredSignatures,
          numReadonlySignedAccounts: numReadonlySignedAccounts,
          numReadonlyUnsignedAccounts: numReadonlyUnsignedAccounts
        },
        recentBlockhash: bs58.encode(Buffer.from(recentBlockhash)),
        accountKeys: accountKeys,
        instructions: instructions
      };
      return new Message(messageArgs);
    }
  }]);
  return Message;
}();

function _createForOfIteratorHelper$3(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$3(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray$3(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$3(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen); }
function _arrayLikeToArray$3(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

/**
 * Message constructor arguments
 */

var MessageV0 = /*#__PURE__*/function () {
  function MessageV0(args) {
    _classCallCheck(this, MessageV0);
    this.header = void 0;
    this.staticAccountKeys = void 0;
    this.recentBlockhash = void 0;
    this.compiledInstructions = void 0;
    this.addressTableLookups = void 0;
    this.header = args.header;
    this.staticAccountKeys = args.staticAccountKeys;
    this.recentBlockhash = args.recentBlockhash;
    this.compiledInstructions = args.compiledInstructions;
    this.addressTableLookups = args.addressTableLookups;
  }
  _createClass(MessageV0, [{
    key: "version",
    get: function get() {
      return 0;
    }
  }, {
    key: "numAccountKeysFromLookups",
    get: function get() {
      var count = 0;
      var _iterator = _createForOfIteratorHelper$3(this.addressTableLookups),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var lookup = _step.value;
          count += lookup.readonlyIndexes.length + lookup.writableIndexes.length;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return count;
    }
  }, {
    key: "getAccountKeys",
    value: function getAccountKeys(args) {
      var accountKeysFromLookups;
      if (args && 'accountKeysFromLookups' in args && args.accountKeysFromLookups) {
        if (this.numAccountKeysFromLookups != args.accountKeysFromLookups.writable.length + args.accountKeysFromLookups.readonly.length) {
          throw new Error('Failed to get account keys because of a mismatch in the number of account keys from lookups');
        }
        accountKeysFromLookups = args.accountKeysFromLookups;
      } else if (args && 'addressLookupTableAccounts' in args && args.addressLookupTableAccounts) {
        accountKeysFromLookups = this.resolveAddressTableLookups(args.addressLookupTableAccounts);
      } else if (this.addressTableLookups.length > 0) {
        throw new Error('Failed to get account keys because address table lookups were not resolved');
      }
      return new MessageAccountKeys(this.staticAccountKeys, accountKeysFromLookups);
    }
  }, {
    key: "isAccountSigner",
    value: function isAccountSigner(index) {
      return index < this.header.numRequiredSignatures;
    }
  }, {
    key: "isAccountWritable",
    value: function isAccountWritable(index) {
      var numSignedAccounts = this.header.numRequiredSignatures;
      var numStaticAccountKeys = this.staticAccountKeys.length;
      if (index >= numStaticAccountKeys) {
        var lookupAccountKeysIndex = index - numStaticAccountKeys;
        var numWritableLookupAccountKeys = this.addressTableLookups.reduce(function (count, lookup) {
          return count + lookup.writableIndexes.length;
        }, 0);
        return lookupAccountKeysIndex < numWritableLookupAccountKeys;
      } else if (index >= this.header.numRequiredSignatures) {
        var unsignedAccountIndex = index - numSignedAccounts;
        var numUnsignedAccounts = numStaticAccountKeys - numSignedAccounts;
        var numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;
        return unsignedAccountIndex < numWritableUnsignedAccounts;
      } else {
        var numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;
        return index < numWritableSignedAccounts;
      }
    }
  }, {
    key: "resolveAddressTableLookups",
    value: function resolveAddressTableLookups(addressLookupTableAccounts) {
      var accountKeysFromLookups = {
        writable: [],
        readonly: []
      };
      var _iterator2 = _createForOfIteratorHelper$3(this.addressTableLookups),
        _step2;
      try {
        var _loop = function _loop() {
          var tableLookup = _step2.value;
          var tableAccount = addressLookupTableAccounts.find(function (account) {
            return account.key.equals(tableLookup.accountKey);
          });
          if (!tableAccount) {
            throw new Error("Failed to find address lookup table account for table key ".concat(tableLookup.accountKey.toBase58()));
          }
          var _iterator3 = _createForOfIteratorHelper$3(tableLookup.writableIndexes),
            _step3;
          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var index = _step3.value;
              if (index < tableAccount.state.addresses.length) {
                accountKeysFromLookups.writable.push(tableAccount.state.addresses[index]);
              } else {
                throw new Error("Failed to find address for index ".concat(index, " in address lookup table ").concat(tableLookup.accountKey.toBase58()));
              }
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
          var _iterator4 = _createForOfIteratorHelper$3(tableLookup.readonlyIndexes),
            _step4;
          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              var _index = _step4.value;
              if (_index < tableAccount.state.addresses.length) {
                accountKeysFromLookups.readonly.push(tableAccount.state.addresses[_index]);
              } else {
                throw new Error("Failed to find address for index ".concat(_index, " in address lookup table ").concat(tableLookup.accountKey.toBase58()));
              }
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }
        };
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          _loop();
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      return accountKeysFromLookups;
    }
  }, {
    key: "serialize",
    value: function serialize() {
      var encodedStaticAccountKeysLength = Array();
      encodeLength(encodedStaticAccountKeysLength, this.staticAccountKeys.length);
      var serializedInstructions = this.serializeInstructions();
      var encodedInstructionsLength = Array();
      encodeLength(encodedInstructionsLength, this.compiledInstructions.length);
      var serializedAddressTableLookups = this.serializeAddressTableLookups();
      var encodedAddressTableLookupsLength = Array();
      encodeLength(encodedAddressTableLookupsLength, this.addressTableLookups.length);
      var messageLayout = BufferLayout.struct([BufferLayout.u8('prefix'), BufferLayout.struct([BufferLayout.u8('numRequiredSignatures'), BufferLayout.u8('numReadonlySignedAccounts'), BufferLayout.u8('numReadonlyUnsignedAccounts')], 'header'), BufferLayout.blob(encodedStaticAccountKeysLength.length, 'staticAccountKeysLength'), BufferLayout.seq(publicKey(), this.staticAccountKeys.length, 'staticAccountKeys'), publicKey('recentBlockhash'), BufferLayout.blob(encodedInstructionsLength.length, 'instructionsLength'), BufferLayout.blob(serializedInstructions.length, 'serializedInstructions'), BufferLayout.blob(encodedAddressTableLookupsLength.length, 'addressTableLookupsLength'), BufferLayout.blob(serializedAddressTableLookups.length, 'serializedAddressTableLookups')]);
      var serializedMessage = new Uint8Array(PACKET_DATA_SIZE);
      var MESSAGE_VERSION_0_PREFIX = 1 << 7;
      var serializedMessageLength = messageLayout.encode({
        prefix: MESSAGE_VERSION_0_PREFIX,
        header: this.header,
        staticAccountKeysLength: new Uint8Array(encodedStaticAccountKeysLength),
        staticAccountKeys: this.staticAccountKeys.map(function (key) {
          return key.toBytes();
        }),
        recentBlockhash: bs58.decode(this.recentBlockhash),
        instructionsLength: new Uint8Array(encodedInstructionsLength),
        serializedInstructions: serializedInstructions,
        addressTableLookupsLength: new Uint8Array(encodedAddressTableLookupsLength),
        serializedAddressTableLookups: serializedAddressTableLookups
      }, serializedMessage);
      return serializedMessage.slice(0, serializedMessageLength);
    }
  }, {
    key: "serializeInstructions",
    value: function serializeInstructions() {
      var serializedLength = 0;
      var serializedInstructions = new Uint8Array(PACKET_DATA_SIZE);
      var _iterator5 = _createForOfIteratorHelper$3(this.compiledInstructions),
        _step5;
      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var instruction = _step5.value;
          var encodedAccountKeyIndexesLength = Array();
          encodeLength(encodedAccountKeyIndexesLength, instruction.accountKeyIndexes.length);
          var encodedDataLength = Array();
          encodeLength(encodedDataLength, instruction.data.length);
          var instructionLayout = BufferLayout.struct([BufferLayout.u8('programIdIndex'), BufferLayout.blob(encodedAccountKeyIndexesLength.length, 'encodedAccountKeyIndexesLength'), BufferLayout.seq(BufferLayout.u8(), instruction.accountKeyIndexes.length, 'accountKeyIndexes'), BufferLayout.blob(encodedDataLength.length, 'encodedDataLength'), BufferLayout.blob(instruction.data.length, 'data')]);
          serializedLength += instructionLayout.encode({
            programIdIndex: instruction.programIdIndex,
            encodedAccountKeyIndexesLength: new Uint8Array(encodedAccountKeyIndexesLength),
            accountKeyIndexes: instruction.accountKeyIndexes,
            encodedDataLength: new Uint8Array(encodedDataLength),
            data: instruction.data
          }, serializedInstructions, serializedLength);
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }
      return serializedInstructions.slice(0, serializedLength);
    }
  }, {
    key: "serializeAddressTableLookups",
    value: function serializeAddressTableLookups() {
      var serializedLength = 0;
      var serializedAddressTableLookups = new Uint8Array(PACKET_DATA_SIZE);
      var _iterator6 = _createForOfIteratorHelper$3(this.addressTableLookups),
        _step6;
      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var lookup = _step6.value;
          var encodedWritableIndexesLength = Array();
          encodeLength(encodedWritableIndexesLength, lookup.writableIndexes.length);
          var encodedReadonlyIndexesLength = Array();
          encodeLength(encodedReadonlyIndexesLength, lookup.readonlyIndexes.length);
          var addressTableLookupLayout = BufferLayout.struct([publicKey('accountKey'), BufferLayout.blob(encodedWritableIndexesLength.length, 'encodedWritableIndexesLength'), BufferLayout.seq(BufferLayout.u8(), lookup.writableIndexes.length, 'writableIndexes'), BufferLayout.blob(encodedReadonlyIndexesLength.length, 'encodedReadonlyIndexesLength'), BufferLayout.seq(BufferLayout.u8(), lookup.readonlyIndexes.length, 'readonlyIndexes')]);
          serializedLength += addressTableLookupLayout.encode({
            accountKey: lookup.accountKey.toBytes(),
            encodedWritableIndexesLength: new Uint8Array(encodedWritableIndexesLength),
            writableIndexes: lookup.writableIndexes,
            encodedReadonlyIndexesLength: new Uint8Array(encodedReadonlyIndexesLength),
            readonlyIndexes: lookup.readonlyIndexes
          }, serializedAddressTableLookups, serializedLength);
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }
      return serializedAddressTableLookups.slice(0, serializedLength);
    }
  }], [{
    key: "compile",
    value: function compile(args) {
      var compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);
      var addressTableLookups = new Array();
      var accountKeysFromLookups = {
        writable: new Array(),
        readonly: new Array()
      };
      var lookupTableAccounts = args.addressLookupTableAccounts || [];
      var _iterator7 = _createForOfIteratorHelper$3(lookupTableAccounts),
        _step7;
      try {
        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
          var lookupTable = _step7.value;
          var extractResult = compiledKeys.extractTableLookup(lookupTable);
          if (extractResult !== undefined) {
            var _accountKeysFromLooku, _accountKeysFromLooku2;
            var _extractResult = _slicedToArray(extractResult, 2),
              addressTableLookup = _extractResult[0],
              _extractResult$ = _extractResult[1],
              writable = _extractResult$.writable,
              readonly = _extractResult$.readonly;
            addressTableLookups.push(addressTableLookup);
            (_accountKeysFromLooku = accountKeysFromLookups.writable).push.apply(_accountKeysFromLooku, _toConsumableArray(writable));
            (_accountKeysFromLooku2 = accountKeysFromLookups.readonly).push.apply(_accountKeysFromLooku2, _toConsumableArray(readonly));
          }
        }
      } catch (err) {
        _iterator7.e(err);
      } finally {
        _iterator7.f();
      }
      var _compiledKeys$getMess = compiledKeys.getMessageComponents(),
        _compiledKeys$getMess2 = _slicedToArray(_compiledKeys$getMess, 2),
        header = _compiledKeys$getMess2[0],
        staticAccountKeys = _compiledKeys$getMess2[1];
      var accountKeys = new MessageAccountKeys(staticAccountKeys, accountKeysFromLookups);
      var compiledInstructions = accountKeys.compileInstructions(args.instructions);
      return new MessageV0({
        header: header,
        staticAccountKeys: staticAccountKeys,
        recentBlockhash: args.recentBlockhash,
        compiledInstructions: compiledInstructions,
        addressTableLookups: addressTableLookups
      });
    }
  }, {
    key: "deserialize",
    value: function deserialize(serializedMessage) {
      var byteArray = _toConsumableArray(serializedMessage);
      var prefix = byteArray.shift();
      var maskedPrefix = prefix & VERSION_PREFIX_MASK;
      assert(prefix !== maskedPrefix, "Expected versioned message but received legacy message");
      var version = maskedPrefix;
      assert(version === 0, "Expected versioned message with version 0 but found version ".concat(version));
      var header = {
        numRequiredSignatures: byteArray.shift(),
        numReadonlySignedAccounts: byteArray.shift(),
        numReadonlyUnsignedAccounts: byteArray.shift()
      };
      var staticAccountKeys = [];
      var staticAccountKeysLength = decodeLength(byteArray);
      for (var i = 0; i < staticAccountKeysLength; i++) {
        staticAccountKeys.push(new PublicKey(byteArray.splice(0, PUBLIC_KEY_LENGTH)));
      }
      var recentBlockhash = bs58.encode(byteArray.splice(0, PUBLIC_KEY_LENGTH));
      var instructionCount = decodeLength(byteArray);
      var compiledInstructions = [];
      for (var _i = 0; _i < instructionCount; _i++) {
        var programIdIndex = byteArray.shift();
        var accountKeyIndexesLength = decodeLength(byteArray);
        var accountKeyIndexes = byteArray.splice(0, accountKeyIndexesLength);
        var dataLength = decodeLength(byteArray);
        var data = new Uint8Array(byteArray.splice(0, dataLength));
        compiledInstructions.push({
          programIdIndex: programIdIndex,
          accountKeyIndexes: accountKeyIndexes,
          data: data
        });
      }
      var addressTableLookupsCount = decodeLength(byteArray);
      var addressTableLookups = [];
      for (var _i2 = 0; _i2 < addressTableLookupsCount; _i2++) {
        var accountKey = new PublicKey(byteArray.splice(0, PUBLIC_KEY_LENGTH));
        var writableIndexesLength = decodeLength(byteArray);
        var writableIndexes = byteArray.splice(0, writableIndexesLength);
        var readonlyIndexesLength = decodeLength(byteArray);
        var readonlyIndexes = byteArray.splice(0, readonlyIndexesLength);
        addressTableLookups.push({
          accountKey: accountKey,
          writableIndexes: writableIndexes,
          readonlyIndexes: readonlyIndexes
        });
      }
      return new MessageV0({
        header: header,
        staticAccountKeys: staticAccountKeys,
        recentBlockhash: recentBlockhash,
        compiledInstructions: compiledInstructions,
        addressTableLookups: addressTableLookups
      });
    }
  }]);
  return MessageV0;
}();

// eslint-disable-next-line no-redeclare
var VersionedMessage = {
  deserializeMessageVersion: function deserializeMessageVersion(serializedMessage) {
    var prefix = serializedMessage[0];
    var maskedPrefix = prefix & VERSION_PREFIX_MASK;

    // if the highest bit of the prefix is not set, the message is not versioned
    if (maskedPrefix === prefix) {
      return 'legacy';
    }

    // the lower 7 bits of the prefix indicate the message version
    return maskedPrefix;
  },
  deserialize: function deserialize(serializedMessage) {
    var version = VersionedMessage.deserializeMessageVersion(serializedMessage);
    if (version === 'legacy') {
      return Message.from(serializedMessage);
    }
    if (version === 0) {
      return MessageV0.deserialize(serializedMessage);
    } else {
      throw new Error("Transaction message version ".concat(version, " deserialization is not supported"));
    }
  }
};

function _createForOfIteratorHelper$2(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$2(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray$2(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$2(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen); }
function _arrayLikeToArray$2(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

/**
 * Transaction signature as base-58 encoded string
 */

var TransactionStatus = /*#__PURE__*/function (TransactionStatus) {
  TransactionStatus[TransactionStatus["BLOCKHEIGHT_EXCEEDED"] = 0] = "BLOCKHEIGHT_EXCEEDED";
  TransactionStatus[TransactionStatus["PROCESSED"] = 1] = "PROCESSED";
  TransactionStatus[TransactionStatus["TIMED_OUT"] = 2] = "TIMED_OUT";
  TransactionStatus[TransactionStatus["NONCE_INVALID"] = 3] = "NONCE_INVALID";
  return TransactionStatus;
}({});

/**
 * Default (empty) signature
 */
var DEFAULT_SIGNATURE = Buffer.alloc(SIGNATURE_LENGTH_IN_BYTES).fill(0);

/**
 * Account metadata used to define instructions
 */

/**
 * List of TransactionInstruction object fields that may be initialized at construction
 */

/**
 * Configuration object for Transaction.serialize()
 */

/**
 * @internal
 */

/**
 * Transaction Instruction class
 */
var TransactionInstruction = /*#__PURE__*/function () {
  function TransactionInstruction(opts) {
    _classCallCheck(this, TransactionInstruction);
    /**
     * Public keys to include in this transaction
     * Boolean represents whether this pubkey needs to sign the transaction
     */
    this.keys = void 0;
    /**
     * Program Id to execute
     */
    this.programId = void 0;
    /**
     * Program input
     */
    this.data = Buffer.alloc(0);
    this.programId = opts.programId;
    this.keys = opts.keys;
    if (opts.data) {
      this.data = opts.data;
    }
  }

  /**
   * @internal
   */
  _createClass(TransactionInstruction, [{
    key: "toJSON",
    value: function toJSON() {
      return {
        keys: this.keys.map(function (_ref) {
          var pubkey = _ref.pubkey,
            isSigner = _ref.isSigner,
            isWritable = _ref.isWritable;
          return {
            pubkey: pubkey.toJSON(),
            isSigner: isSigner,
            isWritable: isWritable
          };
        }),
        programId: this.programId.toJSON(),
        data: _toConsumableArray(this.data)
      };
    }
  }]);
  return TransactionInstruction;
}();

/**
 * Pair of signature and corresponding public key
 */

/**
 * List of Transaction object fields that may be initialized at construction
 */

// For backward compatibility; an unfortunate consequence of being
// forced to over-export types by the documentation generator.
// See https://github.com/solana-labs/solana/pull/25820
/**
 * Blockhash-based transactions have a lifetime that are defined by
 * the blockhash they include. Any transaction whose blockhash is
 * too old will be rejected.
 */
/**
 * Use these options to construct a durable nonce transaction.
 */
/**
 * Nonce information to be used to build an offline Transaction.
 */
/**
 * @internal
 */
/**
 * Transaction class
 */
var Transaction = /*#__PURE__*/function () {
  /**
   * Construct an empty Transaction
   */
  function Transaction(opts) {
    _classCallCheck(this, Transaction);
    /**
     * Signatures for the transaction.  Typically created by invoking the
     * `sign()` method
     */
    this.signatures = [];
    /**
     * The transaction fee payer
     */
    this.feePayer = void 0;
    /**
     * The instructions to atomically execute
     */
    this.instructions = [];
    /**
     * A recent transaction id. Must be populated by the caller
     */
    this.recentBlockhash = void 0;
    /**
     * the last block chain can advance to before tx is declared expired
     * */
    this.lastValidBlockHeight = void 0;
    /**
     * Optional Nonce information. If populated, transaction will use a durable
     * Nonce hash instead of a recentBlockhash. Must be populated by the caller
     */
    this.nonceInfo = void 0;
    /**
     * If this is a nonce transaction this represents the minimum slot from which
     * to evaluate if the nonce has advanced when attempting to confirm the
     * transaction. This protects against a case where the transaction confirmation
     * logic loads the nonce account from an old slot and assumes the mismatch in
     * nonce value implies that the nonce has been advanced.
     */
    this.minNonceContextSlot = void 0;
    /**
     * @internal
     */
    this._message = void 0;
    /**
     * @internal
     */
    this._json = void 0;
    if (!opts) {
      return;
    }
    if (opts.feePayer) {
      this.feePayer = opts.feePayer;
    }
    if (opts.signatures) {
      this.signatures = opts.signatures;
    }
    if (Object.prototype.hasOwnProperty.call(opts, 'nonceInfo')) {
      var _ref2 = opts,
        minContextSlot = _ref2.minContextSlot,
        nonceInfo = _ref2.nonceInfo;
      this.minNonceContextSlot = minContextSlot;
      this.nonceInfo = nonceInfo;
    } else if (Object.prototype.hasOwnProperty.call(opts, 'lastValidBlockHeight')) {
      var _ref3 = opts,
        blockhash = _ref3.blockhash,
        lastValidBlockHeight = _ref3.lastValidBlockHeight;
      this.recentBlockhash = blockhash;
      this.lastValidBlockHeight = lastValidBlockHeight;
    } else {
      var _ref4 = opts,
        recentBlockhash = _ref4.recentBlockhash,
        _nonceInfo = _ref4.nonceInfo;
      if (_nonceInfo) {
        this.nonceInfo = _nonceInfo;
      }
      this.recentBlockhash = recentBlockhash;
    }
  }

  /**
   * @internal
   */
  _createClass(Transaction, [{
    key: "signature",
    get:
    /**
     * The first (payer) Transaction signature
     *
     * @returns {Buffer | null} Buffer of payer's signature
     */
    function get() {
      if (this.signatures.length > 0) {
        return this.signatures[0].signature;
      }
      return null;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        recentBlockhash: this.recentBlockhash || null,
        feePayer: this.feePayer ? this.feePayer.toJSON() : null,
        nonceInfo: this.nonceInfo ? {
          nonce: this.nonceInfo.nonce,
          nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()
        } : null,
        instructions: this.instructions.map(function (instruction) {
          return instruction.toJSON();
        }),
        signers: this.signatures.map(function (_ref5) {
          var publicKey = _ref5.publicKey;
          return publicKey.toJSON();
        })
      };
    }

    /**
     * Add one or more instructions to this Transaction
     *
     * @param {Array< Transaction | TransactionInstruction | TransactionInstructionCtorFields >} items - Instructions to add to the Transaction
     */
  }, {
    key: "add",
    value: function add() {
      var _this = this;
      for (var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++) {
        items[_key] = arguments[_key];
      }
      if (items.length === 0) {
        throw new Error('No instructions');
      }
      items.forEach(function (item) {
        if ('instructions' in item) {
          _this.instructions = _this.instructions.concat(item.instructions);
        } else if ('data' in item && 'programId' in item && 'keys' in item) {
          _this.instructions.push(item);
        } else {
          _this.instructions.push(new TransactionInstruction(item));
        }
      });
      return this;
    }

    /**
     * Compile transaction data
     */
  }, {
    key: "compileMessage",
    value: function compileMessage() {
      if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json)) {
        return this._message;
      }
      var recentBlockhash;
      var instructions;
      if (this.nonceInfo) {
        recentBlockhash = this.nonceInfo.nonce;
        if (this.instructions[0] != this.nonceInfo.nonceInstruction) {
          instructions = [this.nonceInfo.nonceInstruction].concat(_toConsumableArray(this.instructions));
        } else {
          instructions = this.instructions;
        }
      } else {
        recentBlockhash = this.recentBlockhash;
        instructions = this.instructions;
      }
      if (!recentBlockhash) {
        throw new Error('Transaction recentBlockhash required');
      }
      if (instructions.length < 1) {
        console.warn('No instructions provided');
      }
      var feePayer;
      if (this.feePayer) {
        feePayer = this.feePayer;
      } else if (this.signatures.length > 0 && this.signatures[0].publicKey) {
        // Use implicit fee payer
        feePayer = this.signatures[0].publicKey;
      } else {
        throw new Error('Transaction fee payer required');
      }
      for (var i = 0; i < instructions.length; i++) {
        if (instructions[i].programId === undefined) {
          throw new Error("Transaction instruction index ".concat(i, " has undefined program id"));
        }
      }
      var programIds = [];
      var accountMetas = [];
      instructions.forEach(function (instruction) {
        instruction.keys.forEach(function (accountMeta) {
          accountMetas.push(_objectSpread$2({}, accountMeta));
        });
        var programId = instruction.programId.toString();
        if (!programIds.includes(programId)) {
          programIds.push(programId);
        }
      });

      // Append programID account metas
      programIds.forEach(function (programId) {
        accountMetas.push({
          pubkey: new PublicKey(programId),
          isSigner: false,
          isWritable: false
        });
      });

      // Cull duplicate account metas
      var uniqueMetas = [];
      accountMetas.forEach(function (accountMeta) {
        var pubkeyString = accountMeta.pubkey.toString();
        var uniqueIndex = uniqueMetas.findIndex(function (x) {
          return x.pubkey.toString() === pubkeyString;
        });
        if (uniqueIndex > -1) {
          uniqueMetas[uniqueIndex].isWritable = uniqueMetas[uniqueIndex].isWritable || accountMeta.isWritable;
          uniqueMetas[uniqueIndex].isSigner = uniqueMetas[uniqueIndex].isSigner || accountMeta.isSigner;
        } else {
          uniqueMetas.push(accountMeta);
        }
      });

      // Sort. Prioritizing first by signer, then by writable
      uniqueMetas.sort(function (x, y) {
        if (x.isSigner !== y.isSigner) {
          // Signers always come before non-signers
          return x.isSigner ? -1 : 1;
        }
        if (x.isWritable !== y.isWritable) {
          // Writable accounts always come before read-only accounts
          return x.isWritable ? -1 : 1;
        }
        // Otherwise, sort by pubkey, stringwise.
        var options = {
          localeMatcher: 'best fit',
          usage: 'sort',
          sensitivity: 'variant',
          ignorePunctuation: false,
          numeric: false,
          caseFirst: 'lower'
        };
        return x.pubkey.toBase58().localeCompare(y.pubkey.toBase58(), 'en', options);
      });

      // Move fee payer to the front
      var feePayerIndex = uniqueMetas.findIndex(function (x) {
        return x.pubkey.equals(feePayer);
      });
      if (feePayerIndex > -1) {
        var _uniqueMetas$splice = uniqueMetas.splice(feePayerIndex, 1),
          _uniqueMetas$splice2 = _slicedToArray(_uniqueMetas$splice, 1),
          payerMeta = _uniqueMetas$splice2[0];
        payerMeta.isSigner = true;
        payerMeta.isWritable = true;
        uniqueMetas.unshift(payerMeta);
      } else {
        uniqueMetas.unshift({
          pubkey: feePayer,
          isSigner: true,
          isWritable: true
        });
      }

      // Disallow unknown signers
      var _iterator = _createForOfIteratorHelper$2(this.signatures),
        _step;
      try {
        var _loop = function _loop() {
          var signature = _step.value;
          var uniqueIndex = uniqueMetas.findIndex(function (x) {
            return x.pubkey.equals(signature.publicKey);
          });
          if (uniqueIndex > -1) {
            if (!uniqueMetas[uniqueIndex].isSigner) {
              uniqueMetas[uniqueIndex].isSigner = true;
              console.warn('Transaction references a signature that is unnecessary, ' + 'only the fee payer and instruction signer accounts should sign a transaction. ' + 'This behavior is deprecated and will throw an error in the next major version release.');
            }
          } else {
            throw new Error("unknown signer: ".concat(signature.publicKey.toString()));
          }
        };
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          _loop();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      var numRequiredSignatures = 0;
      var numReadonlySignedAccounts = 0;
      var numReadonlyUnsignedAccounts = 0;

      // Split out signing from non-signing keys and count header values
      var signedKeys = [];
      var unsignedKeys = [];
      uniqueMetas.forEach(function (_ref6) {
        var pubkey = _ref6.pubkey,
          isSigner = _ref6.isSigner,
          isWritable = _ref6.isWritable;
        if (isSigner) {
          signedKeys.push(pubkey.toString());
          numRequiredSignatures += 1;
          if (!isWritable) {
            numReadonlySignedAccounts += 1;
          }
        } else {
          unsignedKeys.push(pubkey.toString());
          if (!isWritable) {
            numReadonlyUnsignedAccounts += 1;
          }
        }
      });
      var accountKeys = signedKeys.concat(unsignedKeys);
      var compiledInstructions = instructions.map(function (instruction) {
        var data = instruction.data,
          programId = instruction.programId;
        return {
          programIdIndex: accountKeys.indexOf(programId.toString()),
          accounts: instruction.keys.map(function (meta) {
            return accountKeys.indexOf(meta.pubkey.toString());
          }),
          data: bs58.encode(data)
        };
      });
      compiledInstructions.forEach(function (instruction) {
        assert(instruction.programIdIndex >= 0);
        instruction.accounts.forEach(function (keyIndex) {
          return assert(keyIndex >= 0);
        });
      });
      return new Message({
        header: {
          numRequiredSignatures: numRequiredSignatures,
          numReadonlySignedAccounts: numReadonlySignedAccounts,
          numReadonlyUnsignedAccounts: numReadonlyUnsignedAccounts
        },
        accountKeys: accountKeys,
        recentBlockhash: recentBlockhash,
        instructions: compiledInstructions
      });
    }

    /**
     * @internal
     */
  }, {
    key: "_compile",
    value: function _compile() {
      var message = this.compileMessage();
      var signedKeys = message.accountKeys.slice(0, message.header.numRequiredSignatures);
      if (this.signatures.length === signedKeys.length) {
        var valid = this.signatures.every(function (pair, index) {
          return signedKeys[index].equals(pair.publicKey);
        });
        if (valid) return message;
      }
      this.signatures = signedKeys.map(function (publicKey) {
        return {
          signature: null,
          publicKey: publicKey
        };
      });
      return message;
    }

    /**
     * Get a buffer of the Transaction data that need to be covered by signatures
     */
  }, {
    key: "serializeMessage",
    value: function serializeMessage() {
      return this._compile().serialize();
    }

    /**
     * Get the estimated fee associated with a transaction
     *
     * @param {Connection} connection Connection to RPC Endpoint.
     *
     * @returns {Promise<number | null>} The estimated fee for the transaction
     */
  }, {
    key: "getEstimatedFee",
    value: function () {
      var _getEstimatedFee = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(connection) {
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return connection.getFeeForMessage(this.compileMessage());
            case 2:
              return _context.abrupt("return", _context.sent.value);
            case 3:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function getEstimatedFee(_x) {
        return _getEstimatedFee.apply(this, arguments);
      }
      return getEstimatedFee;
    }()
    /**
     * Specify the public keys which will be used to sign the Transaction.
     * The first signer will be used as the transaction fee payer account.
     *
     * Signatures can be added with either `partialSign` or `addSignature`
     *
     * @deprecated Deprecated since v0.84.0. Only the fee payer needs to be
     * specified and it can be set in the Transaction constructor or with the
     * `feePayer` property.
     */
  }, {
    key: "setSigners",
    value: function setSigners() {
      for (var _len2 = arguments.length, signers = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        signers[_key2] = arguments[_key2];
      }
      if (signers.length === 0) {
        throw new Error('No signers');
      }
      var seen = new Set();
      this.signatures = signers.filter(function (publicKey) {
        var key = publicKey.toString();
        if (seen.has(key)) {
          return false;
        } else {
          seen.add(key);
          return true;
        }
      }).map(function (publicKey) {
        return {
          signature: null,
          publicKey: publicKey
        };
      });
    }

    /**
     * Sign the Transaction with the specified signers. Multiple signatures may
     * be applied to a Transaction. The first signature is considered "primary"
     * and is used identify and confirm transactions.
     *
     * If the Transaction `feePayer` is not set, the first signer will be used
     * as the transaction fee payer account.
     *
     * Transaction fields should not be modified after the first call to `sign`,
     * as doing so may invalidate the signature and cause the Transaction to be
     * rejected.
     *
     * The Transaction must be assigned a valid `recentBlockhash` before invoking this method
     *
     * @param {Array<Signer>} signers Array of signers that will sign the transaction
     */
  }, {
    key: "sign",
    value: function sign() {
      for (var _len3 = arguments.length, signers = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        signers[_key3] = arguments[_key3];
      }
      if (signers.length === 0) {
        throw new Error('No signers');
      }

      // Dedupe signers
      var seen = new Set();
      var uniqueSigners = [];
      for (var _i = 0, _signers = signers; _i < _signers.length; _i++) {
        var signer = _signers[_i];
        var key = signer.publicKey.toString();
        if (seen.has(key)) {
          continue;
        } else {
          seen.add(key);
          uniqueSigners.push(signer);
        }
      }
      this.signatures = uniqueSigners.map(function (signer) {
        return {
          signature: null,
          publicKey: signer.publicKey
        };
      });
      var message = this._compile();
      this._partialSign.apply(this, [message].concat(uniqueSigners));
    }

    /**
     * Partially sign a transaction with the specified accounts. All accounts must
     * correspond to either the fee payer or a signer account in the transaction
     * instructions.
     *
     * All the caveats from the `sign` method apply to `partialSign`
     *
     * @param {Array<Signer>} signers Array of signers that will sign the transaction
     */
  }, {
    key: "partialSign",
    value: function partialSign() {
      for (var _len4 = arguments.length, signers = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        signers[_key4] = arguments[_key4];
      }
      if (signers.length === 0) {
        throw new Error('No signers');
      }

      // Dedupe signers
      var seen = new Set();
      var uniqueSigners = [];
      for (var _i2 = 0, _signers2 = signers; _i2 < _signers2.length; _i2++) {
        var signer = _signers2[_i2];
        var key = signer.publicKey.toString();
        if (seen.has(key)) {
          continue;
        } else {
          seen.add(key);
          uniqueSigners.push(signer);
        }
      }
      var message = this._compile();
      this._partialSign.apply(this, [message].concat(uniqueSigners));
    }

    /**
     * @internal
     */
  }, {
    key: "_partialSign",
    value: function _partialSign(message) {
      var _this2 = this;
      var signData = message.serialize();
      for (var _len5 = arguments.length, signers = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
        signers[_key5 - 1] = arguments[_key5];
      }
      signers.forEach(function (signer) {
        var signature = sign(signData, signer.secretKey);
        _this2._addSignature(signer.publicKey, toBuffer(signature));
      });
    }

    /**
     * Add an externally created signature to a transaction. The public key
     * must correspond to either the fee payer or a signer account in the transaction
     * instructions.
     *
     * @param {PublicKey} pubkey Public key that will be added to the transaction.
     * @param {Buffer} signature An externally created signature to add to the transaction.
     */
  }, {
    key: "addSignature",
    value: function addSignature(pubkey, signature) {
      this._compile(); // Ensure signatures array is populated
      this._addSignature(pubkey, signature);
    }

    /**
     * @internal
     */
  }, {
    key: "_addSignature",
    value: function _addSignature(pubkey, signature) {
      assert(signature.length === 64);
      var index = this.signatures.findIndex(function (sigpair) {
        return pubkey.equals(sigpair.publicKey);
      });
      if (index < 0) {
        throw new Error("unknown signer: ".concat(pubkey.toString()));
      }
      this.signatures[index].signature = Buffer.from(signature);
    }

    /**
     * Verify signatures of a Transaction
     * Optional parameter specifies if we're expecting a fully signed Transaction or a partially signed one.
     * If no boolean is provided, we expect a fully signed Transaction by default.
     *
     * @param {boolean} [requireAllSignatures=true] Require a fully signed Transaction
     */
  }, {
    key: "verifySignatures",
    value: function verifySignatures(requireAllSignatures) {
      return this._verifySignatures(this.serializeMessage(), requireAllSignatures === undefined ? true : requireAllSignatures);
    }

    /**
     * @internal
     */
  }, {
    key: "_verifySignatures",
    value: function _verifySignatures(signData, requireAllSignatures) {
      var _iterator2 = _createForOfIteratorHelper$2(this.signatures),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var _step2$value = _step2.value,
            signature = _step2$value.signature,
            publicKey = _step2$value.publicKey;
          if (signature === null) {
            if (requireAllSignatures) {
              return false;
            }
          } else {
            if (!verify(signature, signData, publicKey.toBytes())) {
              return false;
            }
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      return true;
    }

    /**
     * Serialize the Transaction in the wire format.
     *
     * @param {Buffer} [config] Config of transaction.
     *
     * @returns {Buffer} Signature of transaction in wire format.
     */
  }, {
    key: "serialize",
    value: function serialize(config) {
      var _Object$assign = Object.assign({
          requireAllSignatures: true,
          verifySignatures: true
        }, config),
        requireAllSignatures = _Object$assign.requireAllSignatures,
        verifySignatures = _Object$assign.verifySignatures;
      var signData = this.serializeMessage();
      if (verifySignatures && !this._verifySignatures(signData, requireAllSignatures)) {
        throw new Error('Signature verification failed');
      }
      return this._serialize(signData);
    }

    /**
     * @internal
     */
  }, {
    key: "_serialize",
    value: function _serialize(signData) {
      var signatures = this.signatures;
      var signatureCount = [];
      encodeLength(signatureCount, signatures.length);
      var transactionLength = signatureCount.length + signatures.length * 64 + signData.length;
      var wireTransaction = Buffer.alloc(transactionLength);
      assert(signatures.length < 256);
      Buffer.from(signatureCount).copy(wireTransaction, 0);
      signatures.forEach(function (_ref7, index) {
        var signature = _ref7.signature;
        if (signature !== null) {
          assert(signature.length === 64, "signature has invalid length");
          Buffer.from(signature).copy(wireTransaction, signatureCount.length + index * 64);
        }
      });
      signData.copy(wireTransaction, signatureCount.length + signatures.length * 64);
      assert(wireTransaction.length <= PACKET_DATA_SIZE, "Transaction too large: ".concat(wireTransaction.length, " > ").concat(PACKET_DATA_SIZE));
      return wireTransaction;
    }

    /**
     * Deprecated method
     * @internal
     */
  }, {
    key: "keys",
    get: function get() {
      assert(this.instructions.length === 1);
      return this.instructions[0].keys.map(function (keyObj) {
        return keyObj.pubkey;
      });
    }

    /**
     * Deprecated method
     * @internal
     */
  }, {
    key: "programId",
    get: function get() {
      assert(this.instructions.length === 1);
      return this.instructions[0].programId;
    }

    /**
     * Deprecated method
     * @internal
     */
  }, {
    key: "data",
    get: function get() {
      assert(this.instructions.length === 1);
      return this.instructions[0].data;
    }

    /**
     * Parse a wire transaction into a Transaction object.
     *
     * @param {Buffer | Uint8Array | Array<number>} buffer Signature of wire Transaction
     *
     * @returns {Transaction} Transaction associated with the signature
     */
  }], [{
    key: "from",
    value: function from(buffer) {
      // Slice up wire data
      var byteArray = _toConsumableArray(buffer);
      var signatureCount = decodeLength(byteArray);
      var signatures = [];
      for (var i = 0; i < signatureCount; i++) {
        var signature = byteArray.slice(0, SIGNATURE_LENGTH_IN_BYTES);
        byteArray = byteArray.slice(SIGNATURE_LENGTH_IN_BYTES);
        signatures.push(bs58.encode(Buffer.from(signature)));
      }
      return Transaction.populate(Message.from(byteArray), signatures);
    }

    /**
     * Populate Transaction object from message and signatures
     *
     * @param {Message} message Message of transaction
     * @param {Array<string>} signatures List of signatures to assign to the transaction
     *
     * @returns {Transaction} The populated Transaction
     */
  }, {
    key: "populate",
    value: function populate(message) {
      var signatures = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var transaction = new Transaction();
      transaction.recentBlockhash = message.recentBlockhash;
      if (message.header.numRequiredSignatures > 0) {
        transaction.feePayer = message.accountKeys[0];
      }
      signatures.forEach(function (signature, index) {
        var sigPubkeyPair = {
          signature: signature == bs58.encode(DEFAULT_SIGNATURE) ? null : bs58.decode(signature),
          publicKey: message.accountKeys[index]
        };
        transaction.signatures.push(sigPubkeyPair);
      });
      message.instructions.forEach(function (instruction) {
        var keys = instruction.accounts.map(function (account) {
          var pubkey = message.accountKeys[account];
          return {
            pubkey: pubkey,
            isSigner: transaction.signatures.some(function (keyObj) {
              return keyObj.publicKey.toString() === pubkey.toString();
            }) || message.isAccountSigner(account),
            isWritable: message.isAccountWritable(account)
          };
        });
        transaction.instructions.push(new TransactionInstruction({
          keys: keys,
          programId: message.accountKeys[instruction.programIdIndex],
          data: bs58.decode(instruction.data)
        }));
      });
      transaction._message = message;
      transaction._json = transaction.toJSON();
      return transaction;
    }
  }]);
  return Transaction;
}();

function _createForOfIteratorHelper$1(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray$1(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$1(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen); }
function _arrayLikeToArray$1(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
var TransactionMessage = /*#__PURE__*/function () {
  function TransactionMessage(args) {
    _classCallCheck(this, TransactionMessage);
    this.payerKey = void 0;
    this.instructions = void 0;
    this.recentBlockhash = void 0;
    this.payerKey = args.payerKey;
    this.instructions = args.instructions;
    this.recentBlockhash = args.recentBlockhash;
  }
  _createClass(TransactionMessage, [{
    key: "compileToLegacyMessage",
    value: function compileToLegacyMessage() {
      return Message.compile({
        payerKey: this.payerKey,
        recentBlockhash: this.recentBlockhash,
        instructions: this.instructions
      });
    }
  }, {
    key: "compileToV0Message",
    value: function compileToV0Message(addressLookupTableAccounts) {
      return MessageV0.compile({
        payerKey: this.payerKey,
        recentBlockhash: this.recentBlockhash,
        instructions: this.instructions,
        addressLookupTableAccounts: addressLookupTableAccounts
      });
    }
  }], [{
    key: "decompile",
    value: function decompile(message, args) {
      var header = message.header,
        compiledInstructions = message.compiledInstructions,
        recentBlockhash = message.recentBlockhash;
      var numRequiredSignatures = header.numRequiredSignatures,
        numReadonlySignedAccounts = header.numReadonlySignedAccounts,
        numReadonlyUnsignedAccounts = header.numReadonlyUnsignedAccounts;
      var numWritableSignedAccounts = numRequiredSignatures - numReadonlySignedAccounts;
      assert(numWritableSignedAccounts > 0, 'Message header is invalid');
      var numWritableUnsignedAccounts = message.staticAccountKeys.length - numRequiredSignatures - numReadonlyUnsignedAccounts;
      assert(numWritableUnsignedAccounts >= 0, 'Message header is invalid');
      var accountKeys = message.getAccountKeys(args);
      var payerKey = accountKeys.get(0);
      if (payerKey === undefined) {
        throw new Error('Failed to decompile message because no account keys were found');
      }
      var instructions = [];
      var _iterator = _createForOfIteratorHelper$1(compiledInstructions),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var compiledIx = _step.value;
          var keys = [];
          var _iterator2 = _createForOfIteratorHelper$1(compiledIx.accountKeyIndexes),
            _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var keyIndex = _step2.value;
              var pubkey = accountKeys.get(keyIndex);
              if (pubkey === undefined) {
                throw new Error("Failed to find key for account key index ".concat(keyIndex));
              }
              var isSigner = keyIndex < numRequiredSignatures;
              var isWritable = void 0;
              if (isSigner) {
                isWritable = keyIndex < numWritableSignedAccounts;
              } else if (keyIndex < accountKeys.staticAccountKeys.length) {
                isWritable = keyIndex - numRequiredSignatures < numWritableUnsignedAccounts;
              } else {
                isWritable = keyIndex - accountKeys.staticAccountKeys.length <
                // accountKeysFromLookups cannot be undefined because we already found a pubkey for this index above
                accountKeys.accountKeysFromLookups.writable.length;
              }
              keys.push({
                pubkey: pubkey,
                isSigner: keyIndex < header.numRequiredSignatures,
                isWritable: isWritable
              });
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
          var programId = accountKeys.get(compiledIx.programIdIndex);
          if (programId === undefined) {
            throw new Error("Failed to find program id for program id index ".concat(compiledIx.programIdIndex));
          }
          instructions.push(new TransactionInstruction({
            programId: programId,
            data: toBuffer(compiledIx.data),
            keys: keys
          }));
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return new TransactionMessage({
        payerKey: payerKey,
        instructions: instructions,
        recentBlockhash: recentBlockhash
      });
    }
  }]);
  return TransactionMessage;
}();

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
/**
 * Versioned transaction class
 */
var VersionedTransaction = /*#__PURE__*/function () {
  function VersionedTransaction(message, signatures) {
    _classCallCheck(this, VersionedTransaction);
    this.signatures = void 0;
    this.message = void 0;
    if (signatures !== undefined) {
      assert(signatures.length === message.header.numRequiredSignatures, 'Expected signatures length to be equal to the number of required signatures');
      this.signatures = signatures;
    } else {
      var defaultSignatures = [];
      for (var i = 0; i < message.header.numRequiredSignatures; i++) {
        defaultSignatures.push(new Uint8Array(SIGNATURE_LENGTH_IN_BYTES));
      }
      this.signatures = defaultSignatures;
    }
    this.message = message;
  }
  _createClass(VersionedTransaction, [{
    key: "version",
    get: function get() {
      return this.message.version;
    }
  }, {
    key: "serialize",
    value: function serialize() {
      var serializedMessage = this.message.serialize();
      var encodedSignaturesLength = Array();
      encodeLength(encodedSignaturesLength, this.signatures.length);
      var transactionLayout = BufferLayout.struct([BufferLayout.blob(encodedSignaturesLength.length, 'encodedSignaturesLength'), BufferLayout.seq(signature(), this.signatures.length, 'signatures'), BufferLayout.blob(serializedMessage.length, 'serializedMessage')]);
      var serializedTransaction = new Uint8Array(2048);
      var serializedTransactionLength = transactionLayout.encode({
        encodedSignaturesLength: new Uint8Array(encodedSignaturesLength),
        signatures: this.signatures,
        serializedMessage: serializedMessage
      }, serializedTransaction);
      return serializedTransaction.slice(0, serializedTransactionLength);
    }
  }, {
    key: "sign",
    value: function sign$1(signers) {
      var _this = this;
      var messageData = this.message.serialize();
      var signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
      var _iterator = _createForOfIteratorHelper(signers),
        _step;
      try {
        var _loop = function _loop() {
          var signer = _step.value;
          var signerIndex = signerPubkeys.findIndex(function (pubkey) {
            return pubkey.equals(signer.publicKey);
          });
          assert(signerIndex >= 0, "Cannot sign with non signer key ".concat(signer.publicKey.toBase58()));
          _this.signatures[signerIndex] = sign(messageData, signer.secretKey);
        };
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          _loop();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }, {
    key: "addSignature",
    value: function addSignature(publicKey, signature) {
      assert(signature.byteLength === 64, 'Signature must be 64 bytes long');
      var signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
      var signerIndex = signerPubkeys.findIndex(function (pubkey) {
        return pubkey.equals(publicKey);
      });
      assert(signerIndex >= 0, "Can not add signature; `".concat(publicKey.toBase58(), "` is not required to sign this transaction"));
      this.signatures[signerIndex] = signature;
    }
  }], [{
    key: "deserialize",
    value: function deserialize(serializedTransaction) {
      var byteArray = _toConsumableArray(serializedTransaction);
      var signatures = [];
      var signaturesLength = decodeLength(byteArray);
      for (var i = 0; i < signaturesLength; i++) {
        signatures.push(new Uint8Array(byteArray.splice(0, SIGNATURE_LENGTH_IN_BYTES)));
      }
      var message = VersionedMessage.deserialize(new Uint8Array(byteArray));
      return new VersionedTransaction(message, signatures);
    }
  }]);
  return VersionedTransaction;
}();

// TODO: These constants should be removed in favor of reading them out of a
// Syscall account

/**
 * @internal
 */
var NUM_TICKS_PER_SECOND = 160;

/**
 * @internal
 */
var DEFAULT_TICKS_PER_SLOT = 64;

/**
 * @internal
 */
var NUM_SLOTS_PER_SECOND = NUM_TICKS_PER_SECOND / DEFAULT_TICKS_PER_SLOT;

/**
 * @internal
 */
var MS_PER_SLOT = 1000 / NUM_SLOTS_PER_SECOND;

var SYSVAR_CLOCK_PUBKEY = new PublicKey('SysvarC1ock11111111111111111111111111111111');
var SYSVAR_EPOCH_SCHEDULE_PUBKEY = new PublicKey('SysvarEpochSchedu1e111111111111111111111111');
var SYSVAR_INSTRUCTIONS_PUBKEY = new PublicKey('Sysvar1nstructions1111111111111111111111111');
var SYSVAR_RECENT_BLOCKHASHES_PUBKEY = new PublicKey('SysvarRecentB1ockHashes11111111111111111111');
var SYSVAR_RENT_PUBKEY = new PublicKey('SysvarRent111111111111111111111111111111111');
var SYSVAR_REWARDS_PUBKEY = new PublicKey('SysvarRewards111111111111111111111111111111');
var SYSVAR_SLOT_HASHES_PUBKEY = new PublicKey('SysvarS1otHashes111111111111111111111111111');
var SYSVAR_SLOT_HISTORY_PUBKEY = new PublicKey('SysvarS1otHistory11111111111111111111111111');
var SYSVAR_STAKE_HISTORY_PUBKEY = new PublicKey('SysvarStakeHistory1111111111111111111111111');

/**
 * Sign, send and confirm a transaction.
 *
 * If `commitment` option is not specified, defaults to 'max' commitment.
 *
 * @param {Connection} connection
 * @param {Transaction} transaction
 * @param {Array<Signer>} signers
 * @param {ConfirmOptions} [options]
 * @returns {Promise<TransactionSignature>}
 */
function sendAndConfirmTransaction(_x, _x2, _x3, _x4) {
  return _sendAndConfirmTransaction.apply(this, arguments);
}
function _sendAndConfirmTransaction() {
  _sendAndConfirmTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(connection, transaction, signers, options) {
    var sendOptions, signature, status, nonceInstruction, nonceAccountPubkey;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          sendOptions = options && {
            skipPreflight: options.skipPreflight,
            preflightCommitment: options.preflightCommitment || options.commitment,
            maxRetries: options.maxRetries,
            minContextSlot: options.minContextSlot
          };
          _context.next = 3;
          return connection.sendTransaction(transaction, signers, sendOptions);
        case 3:
          signature = _context.sent;
          if (!(transaction.recentBlockhash != null && transaction.lastValidBlockHeight != null)) {
            _context.next = 10;
            break;
          }
          _context.next = 7;
          return connection.confirmTransaction({
            abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal,
            signature: signature,
            blockhash: transaction.recentBlockhash,
            lastValidBlockHeight: transaction.lastValidBlockHeight
          }, options && options.commitment);
        case 7:
          status = _context.sent.value;
          _context.next = 22;
          break;
        case 10:
          if (!(transaction.minNonceContextSlot != null && transaction.nonceInfo != null)) {
            _context.next = 18;
            break;
          }
          nonceInstruction = transaction.nonceInfo.nonceInstruction;
          nonceAccountPubkey = nonceInstruction.keys[0].pubkey;
          _context.next = 15;
          return connection.confirmTransaction({
            abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal,
            minContextSlot: transaction.minNonceContextSlot,
            nonceAccountPubkey: nonceAccountPubkey,
            nonceValue: transaction.nonceInfo.nonce,
            signature: signature
          }, options && options.commitment);
        case 15:
          status = _context.sent.value;
          _context.next = 22;
          break;
        case 18:
          if ((options === null || options === void 0 ? void 0 : options.abortSignal) != null) {
            console.warn('sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was ' + 'supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` ' + 'or a combination of `nonceInfo` and `minNonceContextSlot` are abortable.');
          }
          _context.next = 21;
          return connection.confirmTransaction(signature, options && options.commitment);
        case 21:
          status = _context.sent.value;
        case 22:
          if (!status.err) {
            _context.next = 24;
            break;
          }
          throw new Error("Transaction ".concat(signature, " failed (").concat(JSON.stringify(status), ")"));
        case 24:
          return _context.abrupt("return", signature);
        case 25:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _sendAndConfirmTransaction.apply(this, arguments);
}

// zzz
function sleep(ms) {
  return new Promise(function (resolve) {
    return setTimeout(resolve, ms);
  });
}

/**
 * @internal
 */

/**
 * Populate a buffer of instruction data using an InstructionType
 * @internal
 */
function encodeData(type, fields) {
  var allocLength = type.layout.span >= 0 ? type.layout.span : getAlloc(type, fields);
  var data = Buffer.alloc(allocLength);
  var layoutFields = Object.assign({
    instruction: type.index
  }, fields);
  type.layout.encode(layoutFields, data);
  return data;
}

/**
 * Decode instruction data buffer using an InstructionType
 * @internal
 */
function decodeData$1(type, buffer) {
  var data;
  try {
    data = type.layout.decode(buffer);
  } catch (err) {
    throw new Error('invalid instruction; ' + err);
  }
  if (data.instruction !== type.index) {
    throw new Error("invalid instruction; instruction index mismatch ".concat(data.instruction, " != ").concat(type.index));
  }
  return data;
}

/**
 * https://github.com/solana-labs/solana/blob/90bedd7e067b5b8f3ddbb45da00a4e9cabb22c62/sdk/src/fee_calculator.rs#L7-L11
 *
 * @internal
 */
var FeeCalculatorLayout = BufferLayout.nu64('lamportsPerSignature');

/**
 * Calculator for transaction fees.
 *
 * @deprecated Deprecated since Solana v1.8.0.
 */

/**
 * See https://github.com/solana-labs/solana/blob/0ea2843ec9cdc517572b8e62c959f41b55cf4453/sdk/src/nonce_state.rs#L29-L32
 *
 * @internal
 */
var NonceAccountLayout = BufferLayout.struct([BufferLayout.u32('version'), BufferLayout.u32('state'), publicKey('authorizedPubkey'), publicKey('nonce'), BufferLayout.struct([FeeCalculatorLayout], 'feeCalculator')]);
var NONCE_ACCOUNT_LENGTH = NonceAccountLayout.span;

/**
 * A durable nonce is a 32 byte value encoded as a base58 string.
 */

/**
 * NonceAccount class
 */
var NonceAccount = /*#__PURE__*/function () {
  /**
   * @internal
   */
  function NonceAccount(args) {
    _classCallCheck(this, NonceAccount);
    this.authorizedPubkey = void 0;
    this.nonce = void 0;
    this.feeCalculator = void 0;
    this.authorizedPubkey = args.authorizedPubkey;
    this.nonce = args.nonce;
    this.feeCalculator = args.feeCalculator;
  }

  /**
   * Deserialize NonceAccount from the account data.
   *
   * @param buffer account data
   * @return NonceAccount
   */
  _createClass(NonceAccount, null, [{
    key: "fromAccountData",
    value: function fromAccountData(buffer) {
      var nonceAccount = NonceAccountLayout.decode(toBuffer(buffer), 0);
      return new NonceAccount({
        authorizedPubkey: new PublicKey(nonceAccount.authorizedPubkey),
        nonce: new PublicKey(nonceAccount.nonce).toString(),
        feeCalculator: nonceAccount.feeCalculator
      });
    }
  }]);
  return NonceAccount;
}();

var encodeDecode = function encodeDecode(layout) {
  var decode = layout.decode.bind(layout);
  var encode = layout.encode.bind(layout);
  return {
    decode: decode,
    encode: encode
  };
};
var bigInt = function bigInt(length) {
  return function (property) {
    var layout = blob(length, property);
    var _encodeDecode = encodeDecode(layout),
      encode = _encodeDecode.encode,
      decode = _encodeDecode.decode;
    var bigIntLayout = layout;
    bigIntLayout.decode = function (buffer, offset) {
      var src = decode(buffer, offset);
      return toBigIntLE(Buffer.from(src));
    };
    bigIntLayout.encode = function (bigInt, buffer, offset) {
      var src = toBufferLE(bigInt, length);
      return encode(src, buffer, offset);
    };
    return bigIntLayout;
  };
};
var u64 = bigInt(8);

/**
 * Create account system transaction params
 */

/**
 * Transfer system transaction params
 */

/**
 * Assign system transaction params
 */

/**
 * Create account with seed system transaction params
 */

/**
 * Create nonce account system transaction params
 */

/**
 * Create nonce account with seed system transaction params
 */

/**
 * Initialize nonce account system instruction params
 */

/**
 * Advance nonce account system instruction params
 */

/**
 * Withdraw nonce account system transaction params
 */

/**
 * Authorize nonce account system transaction params
 */

/**
 * Allocate account system transaction params
 */

/**
 * Allocate account with seed system transaction params
 */

/**
 * Assign account with seed system transaction params
 */

/**
 * Transfer with seed system transaction params
 */

/** Decoded transfer system transaction instruction */

/** Decoded transferWithSeed system transaction instruction */

/**
 * System Instruction class
 */
var SystemInstruction = /*#__PURE__*/function () {
  /**
   * @internal
   */
  function SystemInstruction() {
    _classCallCheck(this, SystemInstruction);
  }

  /**
   * Decode a system instruction and retrieve the instruction type.
   */
  _createClass(SystemInstruction, null, [{
    key: "decodeInstructionType",
    value: function decodeInstructionType(instruction) {
      this.checkProgramId(instruction.programId);
      var instructionTypeLayout = BufferLayout.u32('instruction');
      var typeIndex = instructionTypeLayout.decode(instruction.data);
      var type;
      for (var _i = 0, _Object$entries = Object.entries(SYSTEM_INSTRUCTION_LAYOUTS); _i < _Object$entries.length; _i++) {
        var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
          ixType = _Object$entries$_i[0],
          layout = _Object$entries$_i[1];
        if (layout.index == typeIndex) {
          type = ixType;
          break;
        }
      }
      if (!type) {
        throw new Error('Instruction type incorrect; not a SystemInstruction');
      }
      return type;
    }

    /**
     * Decode a create account system instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeCreateAccount",
    value: function decodeCreateAccount(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 2);
      var _decodeData = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Create, instruction.data),
        lamports = _decodeData.lamports,
        space = _decodeData.space,
        programId = _decodeData.programId;
      return {
        fromPubkey: instruction.keys[0].pubkey,
        newAccountPubkey: instruction.keys[1].pubkey,
        lamports: lamports,
        space: space,
        programId: new PublicKey(programId)
      };
    }

    /**
     * Decode a transfer system instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeTransfer",
    value: function decodeTransfer(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 2);
      var _decodeData2 = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Transfer, instruction.data),
        lamports = _decodeData2.lamports;
      return {
        fromPubkey: instruction.keys[0].pubkey,
        toPubkey: instruction.keys[1].pubkey,
        lamports: lamports
      };
    }

    /**
     * Decode a transfer with seed system instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeTransferWithSeed",
    value: function decodeTransferWithSeed(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 3);
      var _decodeData3 = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed, instruction.data),
        lamports = _decodeData3.lamports,
        seed = _decodeData3.seed,
        programId = _decodeData3.programId;
      return {
        fromPubkey: instruction.keys[0].pubkey,
        basePubkey: instruction.keys[1].pubkey,
        toPubkey: instruction.keys[2].pubkey,
        lamports: lamports,
        seed: seed,
        programId: new PublicKey(programId)
      };
    }

    /**
     * Decode an allocate system instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeAllocate",
    value: function decodeAllocate(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 1);
      var _decodeData4 = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Allocate, instruction.data),
        space = _decodeData4.space;
      return {
        accountPubkey: instruction.keys[0].pubkey,
        space: space
      };
    }

    /**
     * Decode an allocate with seed system instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeAllocateWithSeed",
    value: function decodeAllocateWithSeed(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 1);
      var _decodeData5 = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed, instruction.data),
        base = _decodeData5.base,
        seed = _decodeData5.seed,
        space = _decodeData5.space,
        programId = _decodeData5.programId;
      return {
        accountPubkey: instruction.keys[0].pubkey,
        basePubkey: new PublicKey(base),
        seed: seed,
        space: space,
        programId: new PublicKey(programId)
      };
    }

    /**
     * Decode an assign system instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeAssign",
    value: function decodeAssign(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 1);
      var _decodeData6 = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Assign, instruction.data),
        programId = _decodeData6.programId;
      return {
        accountPubkey: instruction.keys[0].pubkey,
        programId: new PublicKey(programId)
      };
    }

    /**
     * Decode an assign with seed system instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeAssignWithSeed",
    value: function decodeAssignWithSeed(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 1);
      var _decodeData7 = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed, instruction.data),
        base = _decodeData7.base,
        seed = _decodeData7.seed,
        programId = _decodeData7.programId;
      return {
        accountPubkey: instruction.keys[0].pubkey,
        basePubkey: new PublicKey(base),
        seed: seed,
        programId: new PublicKey(programId)
      };
    }

    /**
     * Decode a create account with seed system instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeCreateWithSeed",
    value: function decodeCreateWithSeed(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 2);
      var _decodeData8 = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed, instruction.data),
        base = _decodeData8.base,
        seed = _decodeData8.seed,
        lamports = _decodeData8.lamports,
        space = _decodeData8.space,
        programId = _decodeData8.programId;
      return {
        fromPubkey: instruction.keys[0].pubkey,
        newAccountPubkey: instruction.keys[1].pubkey,
        basePubkey: new PublicKey(base),
        seed: seed,
        lamports: lamports,
        space: space,
        programId: new PublicKey(programId)
      };
    }

    /**
     * Decode a nonce initialize system instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeNonceInitialize",
    value: function decodeNonceInitialize(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 3);
      var _decodeData9 = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount, instruction.data),
        authorized = _decodeData9.authorized;
      return {
        noncePubkey: instruction.keys[0].pubkey,
        authorizedPubkey: new PublicKey(authorized)
      };
    }

    /**
     * Decode a nonce advance system instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeNonceAdvance",
    value: function decodeNonceAdvance(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 3);
      decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount, instruction.data);
      return {
        noncePubkey: instruction.keys[0].pubkey,
        authorizedPubkey: instruction.keys[2].pubkey
      };
    }

    /**
     * Decode a nonce withdraw system instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeNonceWithdraw",
    value: function decodeNonceWithdraw(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 5);
      var _decodeData10 = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount, instruction.data),
        lamports = _decodeData10.lamports;
      return {
        noncePubkey: instruction.keys[0].pubkey,
        toPubkey: instruction.keys[1].pubkey,
        authorizedPubkey: instruction.keys[4].pubkey,
        lamports: lamports
      };
    }

    /**
     * Decode a nonce authorize system instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeNonceAuthorize",
    value: function decodeNonceAuthorize(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 2);
      var _decodeData11 = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount, instruction.data),
        authorized = _decodeData11.authorized;
      return {
        noncePubkey: instruction.keys[0].pubkey,
        authorizedPubkey: instruction.keys[1].pubkey,
        newAuthorizedPubkey: new PublicKey(authorized)
      };
    }

    /**
     * @internal
     */
  }, {
    key: "checkProgramId",
    value: function checkProgramId(programId) {
      if (!programId.equals(SystemProgram.programId)) {
        throw new Error('invalid instruction; programId is not SystemProgram');
      }
    }

    /**
     * @internal
     */
  }, {
    key: "checkKeyLength",
    value: function checkKeyLength(keys, expectedLength) {
      if (keys.length < expectedLength) {
        throw new Error("invalid instruction; found ".concat(keys.length, " keys, expected at least ").concat(expectedLength));
      }
    }
  }]);
  return SystemInstruction;
}();

/**
 * An enumeration of valid SystemInstructionType's
 */

/**
 * An enumeration of valid system InstructionType's
 * @internal
 */
var SYSTEM_INSTRUCTION_LAYOUTS = Object.freeze({
  Create: {
    index: 0,
    layout: BufferLayout.struct([BufferLayout.u32('instruction'), BufferLayout.ns64('lamports'), BufferLayout.ns64('space'), publicKey('programId')])
  },
  Assign: {
    index: 1,
    layout: BufferLayout.struct([BufferLayout.u32('instruction'), publicKey('programId')])
  },
  Transfer: {
    index: 2,
    layout: BufferLayout.struct([BufferLayout.u32('instruction'), u64('lamports')])
  },
  CreateWithSeed: {
    index: 3,
    layout: BufferLayout.struct([BufferLayout.u32('instruction'), publicKey('base'), rustString('seed'), BufferLayout.ns64('lamports'), BufferLayout.ns64('space'), publicKey('programId')])
  },
  AdvanceNonceAccount: {
    index: 4,
    layout: BufferLayout.struct([BufferLayout.u32('instruction')])
  },
  WithdrawNonceAccount: {
    index: 5,
    layout: BufferLayout.struct([BufferLayout.u32('instruction'), BufferLayout.ns64('lamports')])
  },
  InitializeNonceAccount: {
    index: 6,
    layout: BufferLayout.struct([BufferLayout.u32('instruction'), publicKey('authorized')])
  },
  AuthorizeNonceAccount: {
    index: 7,
    layout: BufferLayout.struct([BufferLayout.u32('instruction'), publicKey('authorized')])
  },
  Allocate: {
    index: 8,
    layout: BufferLayout.struct([BufferLayout.u32('instruction'), BufferLayout.ns64('space')])
  },
  AllocateWithSeed: {
    index: 9,
    layout: BufferLayout.struct([BufferLayout.u32('instruction'), publicKey('base'), rustString('seed'), BufferLayout.ns64('space'), publicKey('programId')])
  },
  AssignWithSeed: {
    index: 10,
    layout: BufferLayout.struct([BufferLayout.u32('instruction'), publicKey('base'), rustString('seed'), publicKey('programId')])
  },
  TransferWithSeed: {
    index: 11,
    layout: BufferLayout.struct([BufferLayout.u32('instruction'), u64('lamports'), rustString('seed'), publicKey('programId')])
  },
  UpgradeNonceAccount: {
    index: 12,
    layout: BufferLayout.struct([BufferLayout.u32('instruction')])
  }
});

/**
 * Factory class for transactions to interact with the System program
 */
var SystemProgram = /*#__PURE__*/function () {
  /**
   * @internal
   */
  function SystemProgram() {
    _classCallCheck(this, SystemProgram);
  }

  /**
   * Public key that identifies the System program
   */
  _createClass(SystemProgram, null, [{
    key: "createAccount",
    value:
    /**
     * Generate a transaction instruction that creates a new account
     */
    function createAccount(params) {
      var type = SYSTEM_INSTRUCTION_LAYOUTS.Create;
      var data = encodeData(type, {
        lamports: params.lamports,
        space: params.space,
        programId: toBuffer(params.programId.toBuffer())
      });
      return new TransactionInstruction({
        keys: [{
          pubkey: params.fromPubkey,
          isSigner: true,
          isWritable: true
        }, {
          pubkey: params.newAccountPubkey,
          isSigner: true,
          isWritable: true
        }],
        programId: this.programId,
        data: data
      });
    }

    /**
     * Generate a transaction instruction that transfers lamports from one account to another
     */
  }, {
    key: "transfer",
    value: function transfer(params) {
      var data;
      var keys;
      if ('basePubkey' in params) {
        var type = SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed;
        data = encodeData(type, {
          lamports: BigInt(params.lamports),
          seed: params.seed,
          programId: toBuffer(params.programId.toBuffer())
        });
        keys = [{
          pubkey: params.fromPubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: params.basePubkey,
          isSigner: true,
          isWritable: false
        }, {
          pubkey: params.toPubkey,
          isSigner: false,
          isWritable: true
        }];
      } else {
        var _type = SYSTEM_INSTRUCTION_LAYOUTS.Transfer;
        data = encodeData(_type, {
          lamports: BigInt(params.lamports)
        });
        keys = [{
          pubkey: params.fromPubkey,
          isSigner: true,
          isWritable: true
        }, {
          pubkey: params.toPubkey,
          isSigner: false,
          isWritable: true
        }];
      }
      return new TransactionInstruction({
        keys: keys,
        programId: this.programId,
        data: data
      });
    }

    /**
     * Generate a transaction instruction that assigns an account to a program
     */
  }, {
    key: "assign",
    value: function assign(params) {
      var data;
      var keys;
      if ('basePubkey' in params) {
        var type = SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed;
        data = encodeData(type, {
          base: toBuffer(params.basePubkey.toBuffer()),
          seed: params.seed,
          programId: toBuffer(params.programId.toBuffer())
        });
        keys = [{
          pubkey: params.accountPubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: params.basePubkey,
          isSigner: true,
          isWritable: false
        }];
      } else {
        var _type2 = SYSTEM_INSTRUCTION_LAYOUTS.Assign;
        data = encodeData(_type2, {
          programId: toBuffer(params.programId.toBuffer())
        });
        keys = [{
          pubkey: params.accountPubkey,
          isSigner: true,
          isWritable: true
        }];
      }
      return new TransactionInstruction({
        keys: keys,
        programId: this.programId,
        data: data
      });
    }

    /**
     * Generate a transaction instruction that creates a new account at
     *   an address generated with `from`, a seed, and programId
     */
  }, {
    key: "createAccountWithSeed",
    value: function createAccountWithSeed(params) {
      var type = SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed;
      var data = encodeData(type, {
        base: toBuffer(params.basePubkey.toBuffer()),
        seed: params.seed,
        lamports: params.lamports,
        space: params.space,
        programId: toBuffer(params.programId.toBuffer())
      });
      var keys = [{
        pubkey: params.fromPubkey,
        isSigner: true,
        isWritable: true
      }, {
        pubkey: params.newAccountPubkey,
        isSigner: false,
        isWritable: true
      }];
      if (params.basePubkey != params.fromPubkey) {
        keys.push({
          pubkey: params.basePubkey,
          isSigner: true,
          isWritable: false
        });
      }
      return new TransactionInstruction({
        keys: keys,
        programId: this.programId,
        data: data
      });
    }

    /**
     * Generate a transaction that creates a new Nonce account
     */
  }, {
    key: "createNonceAccount",
    value: function createNonceAccount(params) {
      var transaction = new Transaction();
      if ('basePubkey' in params && 'seed' in params) {
        transaction.add(SystemProgram.createAccountWithSeed({
          fromPubkey: params.fromPubkey,
          newAccountPubkey: params.noncePubkey,
          basePubkey: params.basePubkey,
          seed: params.seed,
          lamports: params.lamports,
          space: NONCE_ACCOUNT_LENGTH,
          programId: this.programId
        }));
      } else {
        transaction.add(SystemProgram.createAccount({
          fromPubkey: params.fromPubkey,
          newAccountPubkey: params.noncePubkey,
          lamports: params.lamports,
          space: NONCE_ACCOUNT_LENGTH,
          programId: this.programId
        }));
      }
      var initParams = {
        noncePubkey: params.noncePubkey,
        authorizedPubkey: params.authorizedPubkey
      };
      transaction.add(this.nonceInitialize(initParams));
      return transaction;
    }

    /**
     * Generate an instruction to initialize a Nonce account
     */
  }, {
    key: "nonceInitialize",
    value: function nonceInitialize(params) {
      var type = SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount;
      var data = encodeData(type, {
        authorized: toBuffer(params.authorizedPubkey.toBuffer())
      });
      var instructionData = {
        keys: [{
          pubkey: params.noncePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: SYSVAR_RENT_PUBKEY,
          isSigner: false,
          isWritable: false
        }],
        programId: this.programId,
        data: data
      };
      return new TransactionInstruction(instructionData);
    }

    /**
     * Generate an instruction to advance the nonce in a Nonce account
     */
  }, {
    key: "nonceAdvance",
    value: function nonceAdvance(params) {
      var type = SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount;
      var data = encodeData(type);
      var instructionData = {
        keys: [{
          pubkey: params.noncePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: params.authorizedPubkey,
          isSigner: true,
          isWritable: false
        }],
        programId: this.programId,
        data: data
      };
      return new TransactionInstruction(instructionData);
    }

    /**
     * Generate a transaction instruction that withdraws lamports from a Nonce account
     */
  }, {
    key: "nonceWithdraw",
    value: function nonceWithdraw(params) {
      var type = SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount;
      var data = encodeData(type, {
        lamports: params.lamports
      });
      return new TransactionInstruction({
        keys: [{
          pubkey: params.noncePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: params.toPubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: SYSVAR_RENT_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: params.authorizedPubkey,
          isSigner: true,
          isWritable: false
        }],
        programId: this.programId,
        data: data
      });
    }

    /**
     * Generate a transaction instruction that authorizes a new PublicKey as the authority
     * on a Nonce account.
     */
  }, {
    key: "nonceAuthorize",
    value: function nonceAuthorize(params) {
      var type = SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount;
      var data = encodeData(type, {
        authorized: toBuffer(params.newAuthorizedPubkey.toBuffer())
      });
      return new TransactionInstruction({
        keys: [{
          pubkey: params.noncePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: params.authorizedPubkey,
          isSigner: true,
          isWritable: false
        }],
        programId: this.programId,
        data: data
      });
    }

    /**
     * Generate a transaction instruction that allocates space in an account without funding
     */
  }, {
    key: "allocate",
    value: function allocate(params) {
      var data;
      var keys;
      if ('basePubkey' in params) {
        var type = SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed;
        data = encodeData(type, {
          base: toBuffer(params.basePubkey.toBuffer()),
          seed: params.seed,
          space: params.space,
          programId: toBuffer(params.programId.toBuffer())
        });
        keys = [{
          pubkey: params.accountPubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: params.basePubkey,
          isSigner: true,
          isWritable: false
        }];
      } else {
        var _type3 = SYSTEM_INSTRUCTION_LAYOUTS.Allocate;
        data = encodeData(_type3, {
          space: params.space
        });
        keys = [{
          pubkey: params.accountPubkey,
          isSigner: true,
          isWritable: true
        }];
      }
      return new TransactionInstruction({
        keys: keys,
        programId: this.programId,
        data: data
      });
    }
  }]);
  return SystemProgram;
}();
SystemProgram.programId = new PublicKey('11111111111111111111111111111111');

// Keep program chunks under PACKET_DATA_SIZE, leaving enough room for the
// rest of the Transaction fields
//
// TODO: replace 300 with a proper constant for the size of the other
// Transaction fields
var CHUNK_SIZE = PACKET_DATA_SIZE - 300;

/**
 * Program loader interface
 */
var Loader = /*#__PURE__*/function () {
  /**
   * @internal
   */
  function Loader() {
    _classCallCheck(this, Loader);
  }

  /**
   * Amount of program data placed in each load Transaction
   */
  _createClass(Loader, null, [{
    key: "getMinNumSignatures",
    value:
    /**
     * Minimum number of signatures required to load a program not including
     * retries
     *
     * Can be used to calculate transaction fees
     */
    function getMinNumSignatures(dataLength) {
      return 2 * (
      // Every transaction requires two signatures (payer + program)
      Math.ceil(dataLength / Loader.chunkSize) + 1 +
      // Add one for Create transaction
      1) // Add one for Finalize transaction
      ;
    }

    /**
     * Loads a generic program
     *
     * @param connection The connection to use
     * @param payer System account that pays to load the program
     * @param program Account to load the program into
     * @param programId Public key that identifies the loader
     * @param data Program octets
     * @return true if program was loaded successfully, false if program was already loaded
     */
  }, {
    key: "load",
    value: function () {
      var _load = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(connection, payer, program, programId, data) {
        var balanceNeeded, programInfo, transaction, dataLayout, chunkSize, offset, array, transactions, bytes, _data, _transaction, REQUESTS_PER_SECOND, _dataLayout, _data2, _transaction2, deployCommitment, finalizeSignature, _yield$connection$con, context, value, currentSlot;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return connection.getMinimumBalanceForRentExemption(data.length);
            case 2:
              balanceNeeded = _context.sent;
              _context.next = 5;
              return connection.getAccountInfo(program.publicKey, 'confirmed');
            case 5:
              programInfo = _context.sent;
              transaction = null;
              if (!(programInfo !== null)) {
                _context.next = 16;
                break;
              }
              if (!programInfo.executable) {
                _context.next = 11;
                break;
              }
              console.error('Program load failed, account is already executable');
              return _context.abrupt("return", false);
            case 11:
              if (programInfo.data.length !== data.length) {
                transaction = transaction || new Transaction();
                transaction.add(SystemProgram.allocate({
                  accountPubkey: program.publicKey,
                  space: data.length
                }));
              }
              if (!programInfo.owner.equals(programId)) {
                transaction = transaction || new Transaction();
                transaction.add(SystemProgram.assign({
                  accountPubkey: program.publicKey,
                  programId: programId
                }));
              }
              if (programInfo.lamports < balanceNeeded) {
                transaction = transaction || new Transaction();
                transaction.add(SystemProgram.transfer({
                  fromPubkey: payer.publicKey,
                  toPubkey: program.publicKey,
                  lamports: balanceNeeded - programInfo.lamports
                }));
              }
              _context.next = 17;
              break;
            case 16:
              transaction = new Transaction().add(SystemProgram.createAccount({
                fromPubkey: payer.publicKey,
                newAccountPubkey: program.publicKey,
                lamports: balanceNeeded > 0 ? balanceNeeded : 1,
                space: data.length,
                programId: programId
              }));
            case 17:
              if (!(transaction !== null)) {
                _context.next = 20;
                break;
              }
              _context.next = 20;
              return sendAndConfirmTransaction(connection, transaction, [payer, program], {
                commitment: 'confirmed'
              });
            case 20:
              dataLayout = BufferLayout.struct([BufferLayout.u32('instruction'), BufferLayout.u32('offset'), BufferLayout.u32('bytesLength'), BufferLayout.u32('bytesLengthPadding'), BufferLayout.seq(BufferLayout.u8('byte'), BufferLayout.offset(BufferLayout.u32(), -8), 'bytes')]);
              chunkSize = Loader.chunkSize;
              offset = 0;
              array = data;
              transactions = [];
            case 25:
              if (!(array.length > 0)) {
                _context.next = 39;
                break;
              }
              bytes = array.slice(0, chunkSize);
              _data = Buffer.alloc(chunkSize + 16);
              dataLayout.encode({
                instruction: 0,
                // Load instruction
                offset: offset,
                bytes: bytes,
                bytesLength: 0,
                bytesLengthPadding: 0
              }, _data);
              _transaction = new Transaction().add({
                keys: [{
                  pubkey: program.publicKey,
                  isSigner: true,
                  isWritable: true
                }],
                programId: programId,
                data: _data
              });
              transactions.push(sendAndConfirmTransaction(connection, _transaction, [payer, program], {
                commitment: 'confirmed'
              }));

              // Delay between sends in an attempt to reduce rate limit errors
              if (!connection._rpcEndpoint.includes('solana.com')) {
                _context.next = 35;
                break;
              }
              REQUESTS_PER_SECOND = 4;
              _context.next = 35;
              return sleep(1000 / REQUESTS_PER_SECOND);
            case 35:
              offset += chunkSize;
              array = array.slice(chunkSize);
              _context.next = 25;
              break;
            case 39:
              _context.next = 41;
              return Promise.all(transactions);
            case 41:
              _dataLayout = BufferLayout.struct([BufferLayout.u32('instruction')]);
              _data2 = Buffer.alloc(_dataLayout.span);
              _dataLayout.encode({
                instruction: 1 // Finalize instruction
              }, _data2);
              _transaction2 = new Transaction().add({
                keys: [{
                  pubkey: program.publicKey,
                  isSigner: true,
                  isWritable: true
                }, {
                  pubkey: SYSVAR_RENT_PUBKEY,
                  isSigner: false,
                  isWritable: false
                }],
                programId: programId,
                data: _data2
              });
              deployCommitment = 'processed';
              _context.next = 48;
              return connection.sendTransaction(_transaction2, [payer, program], {
                preflightCommitment: deployCommitment
              });
            case 48:
              finalizeSignature = _context.sent;
              _context.next = 51;
              return connection.confirmTransaction({
                signature: finalizeSignature,
                lastValidBlockHeight: _transaction2.lastValidBlockHeight,
                blockhash: _transaction2.recentBlockhash
              }, deployCommitment);
            case 51:
              _yield$connection$con = _context.sent;
              context = _yield$connection$con.context;
              value = _yield$connection$con.value;
              if (!value.err) {
                _context.next = 56;
                break;
              }
              throw new Error("Transaction ".concat(finalizeSignature, " failed (").concat(JSON.stringify(value), ")"));
            case 56:
              _context.prev = 57;
              _context.next = 60;
              return connection.getSlot({
                commitment: deployCommitment
              });
            case 60:
              currentSlot = _context.sent;
              if (!(currentSlot > context.slot)) {
                _context.next = 63;
                break;
              }
              return _context.abrupt("break", 71);
            case 63:
              _context.next = 67;
              break;
            case 65:
              _context.prev = 65;
              _context.t0 = _context["catch"](57);
            case 67:
              _context.next = 69;
              return new Promise(function (resolve) {
                return setTimeout(resolve, Math.round(MS_PER_SLOT / 2));
              });
            case 69:
              _context.next = 56;
              break;
            case 71:
              return _context.abrupt("return", true);
            case 72:
            case "end":
              return _context.stop();
          }
        }, _callee, null, [[57, 65]]);
      }));
      function load(_x, _x2, _x3, _x4, _x5) {
        return _load.apply(this, arguments);
      }
      return load;
    }()
  }]);
  return Loader;
}();
Loader.chunkSize = CHUNK_SIZE;

var BPF_LOADER_PROGRAM_ID = new PublicKey('BPFLoader2111111111111111111111111111111111');

/**
 * Factory class for transactions to interact with a program loader
 */
var BpfLoader = /*#__PURE__*/function () {
  function BpfLoader() {
    _classCallCheck(this, BpfLoader);
  }
  _createClass(BpfLoader, null, [{
    key: "getMinNumSignatures",
    value:
    /**
     * Minimum number of signatures required to load a program not including
     * retries
     *
     * Can be used to calculate transaction fees
     */
    function getMinNumSignatures(dataLength) {
      return Loader.getMinNumSignatures(dataLength);
    }

    /**
     * Load a SBF program
     *
     * @param connection The connection to use
     * @param payer Account that will pay program loading fees
     * @param program Account to load the program into
     * @param elf The entire ELF containing the SBF program
     * @param loaderProgramId The program id of the BPF loader to use
     * @return true if program was loaded successfully, false if program was already loaded
     */
  }, {
    key: "load",
    value: function load(connection, payer, program, elf, loaderProgramId) {
      return Loader.load(connection, payer, program, loaderProgramId, elf);
    }
  }]);
  return BpfLoader;
}();

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var objToString = Object.prototype.toString;
var objKeys = Object.keys || function(obj) {
		var keys = [];
		for (var name in obj) {
			keys.push(name);
		}
		return keys;
	};

function stringify(val, isArrayProp) {
	var i, max, str, keys, key, propVal, toStr;
	if (val === true) {
		return "true";
	}
	if (val === false) {
		return "false";
	}
	switch (typeof val) {
		case "object":
			if (val === null) {
				return null;
			} else if (val.toJSON && typeof val.toJSON === "function") {
				return stringify(val.toJSON(), isArrayProp);
			} else {
				toStr = objToString.call(val);
				if (toStr === "[object Array]") {
					str = '[';
					max = val.length - 1;
					for(i = 0; i < max; i++) {
						str += stringify(val[i], true) + ',';
					}
					if (max > -1) {
						str += stringify(val[i], true);
					}
					return str + ']';
				} else if (toStr === "[object Object]") {
					// only object is left
					keys = objKeys(val).sort();
					max = keys.length;
					str = "";
					i = 0;
					while (i < max) {
						key = keys[i];
						propVal = stringify(val[key], false);
						if (propVal !== undefined) {
							if (str) {
								str += ',';
							}
							str += JSON.stringify(key) + ':' + propVal;
						}
						i++;
					}
					return '{' + str + '}';
				} else {
					return JSON.stringify(val);
				}
			}
		case "function":
		case "undefined":
			return isArrayProp ? null : undefined;
		case "string":
			return JSON.stringify(val);
		default:
			return isFinite(val) ? val : null;
	}
}

var fastStableStringify = function(val) {
	var returnVal = stringify(val, false);
	if (returnVal !== undefined) {
		return ''+ returnVal;
	}
};

var fastStableStringify$1 = /*@__PURE__*/getDefaultExportFromCjs(fastStableStringify);

var MINIMUM_SLOT_PER_EPOCH = 32;

// Returns the number of trailing zeros in the binary representation of self.
function trailingZeros(n) {
  var trailingZeros = 0;
  while (n > 1) {
    n /= 2;
    trailingZeros++;
  }
  return trailingZeros;
}

// Returns the smallest power of two greater than or equal to n
function nextPowerOfTwo(n) {
  if (n === 0) return 1;
  n--;
  n |= n >> 1;
  n |= n >> 2;
  n |= n >> 4;
  n |= n >> 8;
  n |= n >> 16;
  n |= n >> 32;
  return n + 1;
}

/**
 * Epoch schedule
 * (see https://docs.solana.com/terminology#epoch)
 * Can be retrieved with the {@link Connection.getEpochSchedule} method
 */
var EpochSchedule = /*#__PURE__*/function () {
  function EpochSchedule(slotsPerEpoch, leaderScheduleSlotOffset, warmup, firstNormalEpoch, firstNormalSlot) {
    _classCallCheck(this, EpochSchedule);
    /** The maximum number of slots in each epoch */
    this.slotsPerEpoch = void 0;
    /** The number of slots before beginning of an epoch to calculate a leader schedule for that epoch */
    this.leaderScheduleSlotOffset = void 0;
    /** Indicates whether epochs start short and grow */
    this.warmup = void 0;
    /** The first epoch with `slotsPerEpoch` slots */
    this.firstNormalEpoch = void 0;
    /** The first slot of `firstNormalEpoch` */
    this.firstNormalSlot = void 0;
    this.slotsPerEpoch = slotsPerEpoch;
    this.leaderScheduleSlotOffset = leaderScheduleSlotOffset;
    this.warmup = warmup;
    this.firstNormalEpoch = firstNormalEpoch;
    this.firstNormalSlot = firstNormalSlot;
  }
  _createClass(EpochSchedule, [{
    key: "getEpoch",
    value: function getEpoch(slot) {
      return this.getEpochAndSlotIndex(slot)[0];
    }
  }, {
    key: "getEpochAndSlotIndex",
    value: function getEpochAndSlotIndex(slot) {
      if (slot < this.firstNormalSlot) {
        var epoch = trailingZeros(nextPowerOfTwo(slot + MINIMUM_SLOT_PER_EPOCH + 1)) - trailingZeros(MINIMUM_SLOT_PER_EPOCH) - 1;
        var epochLen = this.getSlotsInEpoch(epoch);
        var slotIndex = slot - (epochLen - MINIMUM_SLOT_PER_EPOCH);
        return [epoch, slotIndex];
      } else {
        var normalSlotIndex = slot - this.firstNormalSlot;
        var normalEpochIndex = Math.floor(normalSlotIndex / this.slotsPerEpoch);
        var _epoch = this.firstNormalEpoch + normalEpochIndex;
        var _slotIndex = normalSlotIndex % this.slotsPerEpoch;
        return [_epoch, _slotIndex];
      }
    }
  }, {
    key: "getFirstSlotInEpoch",
    value: function getFirstSlotInEpoch(epoch) {
      if (epoch <= this.firstNormalEpoch) {
        return (Math.pow(2, epoch) - 1) * MINIMUM_SLOT_PER_EPOCH;
      } else {
        return (epoch - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot;
      }
    }
  }, {
    key: "getLastSlotInEpoch",
    value: function getLastSlotInEpoch(epoch) {
      return this.getFirstSlotInEpoch(epoch) + this.getSlotsInEpoch(epoch) - 1;
    }
  }, {
    key: "getSlotsInEpoch",
    value: function getSlotsInEpoch(epoch) {
      if (epoch < this.firstNormalEpoch) {
        return Math.pow(2, epoch + trailingZeros(MINIMUM_SLOT_PER_EPOCH));
      } else {
        return this.slotsPerEpoch;
      }
    }
  }]);
  return EpochSchedule;
}();

function _createSuper$1(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct$1() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var SendTransactionError = /*#__PURE__*/function (_Error) {
  _inherits(SendTransactionError, _Error);
  var _super = _createSuper$1(SendTransactionError);
  function SendTransactionError(message, logs) {
    var _this;
    _classCallCheck(this, SendTransactionError);
    _this = _super.call(this, message);
    _this.logs = void 0;
    _this.logs = logs;
    return _this;
  }
  return _createClass(SendTransactionError);
}( /*#__PURE__*/_wrapNativeSuper(Error));

// Keep in sync with client/src/rpc_custom_errors.rs
// Typescript `enums` thwart tree-shaking. See https://bargsten.org/jsts/enums/
var SolanaJSONRPCErrorCode = {
  JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP: -32001,
  JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE: -32002,
  JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE: -32003,
  JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE: -32004,
  JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY: -32005,
  JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE: -32006,
  JSON_RPC_SERVER_ERROR_SLOT_SKIPPED: -32007,
  JSON_RPC_SERVER_ERROR_NO_SNAPSHOT: -32008,
  JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED: -32009,
  JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX: -32010,
  JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE: -32011,
  JSON_RPC_SCAN_ERROR: -32012,
  JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH: -32013,
  JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET: -32014,
  JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION: -32015,
  JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED: -32016
};
var SolanaJSONRPCError = /*#__PURE__*/function (_Error2) {
  _inherits(SolanaJSONRPCError, _Error2);
  var _super2 = _createSuper$1(SolanaJSONRPCError);
  function SolanaJSONRPCError(_ref, customMessage) {
    var _this2;
    var code = _ref.code,
      message = _ref.message,
      data = _ref.data;
    _classCallCheck(this, SolanaJSONRPCError);
    _this2 = _super2.call(this, customMessage != null ? "".concat(customMessage, ": ").concat(message) : message);
    _this2.code = void 0;
    _this2.data = void 0;
    _this2.code = code;
    _this2.data = data;
    _this2.name = 'SolanaJSONRPCError';
    return _this2;
  }
  return _createClass(SolanaJSONRPCError);
}( /*#__PURE__*/_wrapNativeSuper(Error));

var fetchImpl = globalThis.fetch;

function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var RpcWebSocketClient = /*#__PURE__*/function (_RpcWebSocketCommonCl) {
  _inherits(RpcWebSocketClient, _RpcWebSocketCommonCl);
  var _super = _createSuper(RpcWebSocketClient);
  function RpcWebSocketClient(address, options, generate_request_id) {
    var _this;
    _classCallCheck(this, RpcWebSocketClient);
    var webSocketFactory = function webSocketFactory(url) {
      var rpc = createRpc(url, _objectSpread$1({
        autoconnect: true,
        max_reconnects: 5,
        reconnect: true,
        reconnect_interval: 1000
      }, options));
      if ('socket' in rpc) {
        _this.underlyingSocket = rpc.socket;
      } else {
        _this.underlyingSocket = rpc;
      }
      return rpc;
    };
    _this = _super.call(this, webSocketFactory, address, options, generate_request_id);
    _this.underlyingSocket = void 0;
    return _this;
  }
  _createClass(RpcWebSocketClient, [{
    key: "call",
    value: function call() {
      var _this$underlyingSocke;
      var readyState = (_this$underlyingSocke = this.underlyingSocket) === null || _this$underlyingSocke === void 0 ? void 0 : _this$underlyingSocke.readyState;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      if (readyState === 1 /* WebSocket.OPEN */) {
        var _get2;
        return (_get2 = _get(_getPrototypeOf(RpcWebSocketClient.prototype), "call", this)).call.apply(_get2, [this].concat(args));
      }
      return Promise.reject(new Error('Tried to call a JSON-RPC method `' + args[0] + '` but the socket was not `CONNECTING` or `OPEN` (`readyState` was ' + readyState + ')'));
    }
  }, {
    key: "notify",
    value: function notify() {
      var _this$underlyingSocke2;
      var readyState = (_this$underlyingSocke2 = this.underlyingSocket) === null || _this$underlyingSocke2 === void 0 ? void 0 : _this$underlyingSocke2.readyState;
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      if (readyState === 1 /* WebSocket.OPEN */) {
        var _get3;
        return (_get3 = _get(_getPrototypeOf(RpcWebSocketClient.prototype), "notify", this)).call.apply(_get3, [this].concat(args));
      }
      return Promise.reject(new Error('Tried to send a JSON-RPC notification `' + args[0] + '` but the socket was not `CONNECTING` or `OPEN` (`readyState` was ' + readyState + ')'));
    }
  }]);
  return RpcWebSocketClient;
}(RpcWebSocketCommonClient);

/**
 * @internal
 */

/**
 * Decode account data buffer using an AccountType
 * @internal
 */
function decodeData(type, data) {
  var decoded;
  try {
    decoded = type.layout.decode(data);
  } catch (err) {
    throw new Error('invalid instruction; ' + err);
  }
  if (decoded.typeIndex !== type.index) {
    throw new Error("invalid account data; account type mismatch ".concat(decoded.typeIndex, " != ").concat(type.index));
  }
  return decoded;
}

/// The serialized size of lookup table metadata
var LOOKUP_TABLE_META_SIZE = 56;
var AddressLookupTableAccount = /*#__PURE__*/function () {
  function AddressLookupTableAccount(args) {
    _classCallCheck(this, AddressLookupTableAccount);
    this.key = void 0;
    this.state = void 0;
    this.key = args.key;
    this.state = args.state;
  }
  _createClass(AddressLookupTableAccount, [{
    key: "isActive",
    value: function isActive() {
      var U64_MAX = BigInt('0xffffffffffffffff');
      return this.state.deactivationSlot === U64_MAX;
    }
  }], [{
    key: "deserialize",
    value: function deserialize(accountData) {
      var meta = decodeData(LookupTableMetaLayout, accountData);
      var serializedAddressesLen = accountData.length - LOOKUP_TABLE_META_SIZE;
      assert(serializedAddressesLen >= 0, 'lookup table is invalid');
      assert(serializedAddressesLen % 32 === 0, 'lookup table is invalid');
      var numSerializedAddresses = serializedAddressesLen / 32;
      var _BufferLayout$struct$ = BufferLayout.struct([BufferLayout.seq(publicKey(), numSerializedAddresses, 'addresses')]).decode(accountData.slice(LOOKUP_TABLE_META_SIZE)),
        addresses = _BufferLayout$struct$.addresses;
      return {
        deactivationSlot: meta.deactivationSlot,
        lastExtendedSlot: meta.lastExtendedSlot,
        lastExtendedSlotStartIndex: meta.lastExtendedStartIndex,
        authority: meta.authority.length !== 0 ? new PublicKey(meta.authority[0]) : undefined,
        addresses: addresses.map(function (address) {
          return new PublicKey(address);
        })
      };
    }
  }]);
  return AddressLookupTableAccount;
}();
var LookupTableMetaLayout = {
  index: 1,
  layout: BufferLayout.struct([BufferLayout.u32('typeIndex'), u64('deactivationSlot'), BufferLayout.nu64('lastExtendedSlot'), BufferLayout.u8('lastExtendedStartIndex'), BufferLayout.u8(),
  // option
  BufferLayout.seq(publicKey(), BufferLayout.offset(BufferLayout.u8(), -1), 'authority')])
};

var URL_RE = /^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;
function makeWebsocketUrl(endpoint) {
  var matches = endpoint.match(URL_RE);
  if (matches == null) {
    throw TypeError("Failed to validate endpoint URL `".concat(endpoint, "`"));
  }
  var _matches = _slicedToArray(matches, 4);
    _matches[0];
    var // eslint-disable-line @typescript-eslint/no-unused-vars
    hostish = _matches[1],
    portWithColon = _matches[2],
    rest = _matches[3];
  var protocol = endpoint.startsWith('https:') ? 'wss:' : 'ws:';
  var startPort = portWithColon == null ? null : parseInt(portWithColon.slice(1), 10);
  var websocketPort =
  // Only shift the port by +1 as a convention for ws(s) only if given endpoint
  // is explictly specifying the endpoint port (HTTP-based RPC), assuming
  // we're directly trying to connect to solana-validator's ws listening port.
  // When the endpoint omits the port, we're connecting to the protocol
  // default ports: http(80) or https(443) and it's assumed we're behind a reverse
  // proxy which manages WebSocket upgrade and backend port redirection.
  startPort == null ? '' : ":".concat(startPort + 1);
  return "".concat(protocol, "//").concat(hostish).concat(websocketPort).concat(rest);
}

var _process$env$npm_pack;
var _excluded = ["commitment"],
  _excluded2 = ["encoding"],
  _excluded3 = ["commitment"],
  _excluded4 = ["commitment"];
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var PublicKeyFromString = coerce(instance(PublicKey), string(), function (value) {
  return new PublicKey(value);
});
var RawAccountDataResult = tuple([string(), literal('base64')]);
var BufferFromRawAccountData = coerce(instance(Buffer), RawAccountDataResult, function (value) {
  return Buffer.from(value[0], 'base64');
});

/**
 * Attempt to use a recent blockhash for up to 30 seconds
 * @internal
 */
var BLOCKHASH_CACHE_TIMEOUT_MS = 30 * 1000;

/**
 * HACK.
 * Copied from rpc-websockets/dist/lib/client.
 * Otherwise, `yarn build` fails with:
 * https://gist.github.com/steveluscher/c057eca81d479ef705cdb53162f9971d
 */

/** @internal */
/** @internal */
/** @internal */
/** @internal */

/** @internal */
/**
 * @internal
 * Every subscription contains the args used to open the subscription with
 * the server, and a list of callers interested in notifications.
 */

/**
 * @internal
 * A subscription may be in various states of connectedness. Only when it is
 * fully connected will it have a server subscription id associated with it.
 * This id can be returned to the server to unsubscribe the client entirely.
 */

/**
 * A type that encapsulates a subscription's RPC method
 * names and notification (callback) signature.
 */

/**
 * @internal
 * Utility type that keeps tagged unions intact while omitting properties.
 */

/**
 * @internal
 * This type represents a single subscribable 'topic.' It's made up of:
 *
 * - The args used to open the subscription with the server,
 * - The state of the subscription, in terms of its connectedness, and
 * - The set of callbacks to call when the server publishes notifications
 *
 * This record gets indexed by `SubscriptionConfigHash` and is used to
 * set up subscriptions, fan out notifications, and track subscription state.
 */

/**
 * @internal
 */

/**
 * Extra contextual information for RPC responses
 */

/**
 * Options for sending transactions
 */

/**
 * Options for confirming transactions
 */

/**
 * Options for getConfirmedSignaturesForAddress2
 */

/**
 * Options for getSignaturesForAddress
 */

/**
 * RPC Response with extra contextual information
 */

/**
 * A strategy for confirming transactions that uses the last valid
 * block height for a given blockhash to check for transaction expiration.
 */

/**
 * A strategy for confirming durable nonce transactions.
 */

/**
 * Properties shared by all transaction confirmation strategies
 */

/**
 * This type represents all transaction confirmation strategies
 */

/* @internal */
function assertEndpointUrl(putativeUrl) {
  if (/^https?:/.test(putativeUrl) === false) {
    throw new TypeError('Endpoint URL must start with `http:` or `https:`.');
  }
  return putativeUrl;
}

/** @internal */
function extractCommitmentFromConfig(commitmentOrConfig) {
  var commitment;
  var config;
  if (typeof commitmentOrConfig === 'string') {
    commitment = commitmentOrConfig;
  } else if (commitmentOrConfig) {
    var specifiedCommitment = commitmentOrConfig.commitment,
      specifiedConfig = _objectWithoutProperties(commitmentOrConfig, _excluded);
    commitment = specifiedCommitment;
    config = specifiedConfig;
  }
  return {
    commitment: commitment,
    config: config
  };
}

/**
 * @internal
 */
function createRpcResult(result) {
  return union([type({
    jsonrpc: literal('2.0'),
    id: string(),
    result: result
  }), type({
    jsonrpc: literal('2.0'),
    id: string(),
    error: type({
      code: unknown(),
      message: string(),
      data: optional(any())
    })
  })]);
}
var UnknownRpcResult = createRpcResult(unknown());

/**
 * @internal
 */
function jsonRpcResult(schema) {
  return coerce(createRpcResult(schema), UnknownRpcResult, function (value) {
    if ('error' in value) {
      return value;
    } else {
      return _objectSpread(_objectSpread({}, value), {}, {
        result: create(value.result, schema)
      });
    }
  });
}

/**
 * @internal
 */
function jsonRpcResultAndContext(value) {
  return jsonRpcResult(type({
    context: type({
      slot: number()
    }),
    value: value
  }));
}

/**
 * @internal
 */
function notificationResultAndContext(value) {
  return type({
    context: type({
      slot: number()
    }),
    value: value
  });
}

/**
 * @internal
 */
function versionedMessageFromResponse(version, response) {
  if (version === 0) {
    return new MessageV0({
      header: response.header,
      staticAccountKeys: response.accountKeys.map(function (accountKey) {
        return new PublicKey(accountKey);
      }),
      recentBlockhash: response.recentBlockhash,
      compiledInstructions: response.instructions.map(function (ix) {
        return {
          programIdIndex: ix.programIdIndex,
          accountKeyIndexes: ix.accounts,
          data: bs58.decode(ix.data)
        };
      }),
      addressTableLookups: response.addressTableLookups
    });
  } else {
    return new Message(response);
  }
}

/**
 * The level of commitment desired when querying state
 * <pre>
 *   'processed': Query the most recent block which has reached 1 confirmation by the connected node
 *   'confirmed': Query the most recent block which has reached 1 confirmation by the cluster
 *   'finalized': Query the most recent block which has been finalized by the cluster
 * </pre>
 */

// Deprecated as of v1.5.5
/**
 * A subset of Commitment levels, which are at least optimistically confirmed
 * <pre>
 *   'confirmed': Query the most recent block which has reached 1 confirmation by the cluster
 *   'finalized': Query the most recent block which has been finalized by the cluster
 * </pre>
 */
/**
 * Filter for largest accounts query
 * <pre>
 *   'circulating':    Return the largest accounts that are part of the circulating supply
 *   'nonCirculating': Return the largest accounts that are not part of the circulating supply
 * </pre>
 */
/**
 * Configuration object for changing `getAccountInfo` query behavior
 */
/**
 * Configuration object for changing `getBalance` query behavior
 */
/**
 * Configuration object for changing `getBlock` query behavior
 */
/**
 * Configuration object for changing `getBlock` query behavior
 */
/**
 * Configuration object for changing `getStakeMinimumDelegation` query behavior
 */
/**
 * Configuration object for changing `getBlockHeight` query behavior
 */
/**
 * Configuration object for changing `getEpochInfo` query behavior
 */
/**
 * Configuration object for changing `getInflationReward` query behavior
 */
/**
 * Configuration object for changing `getLatestBlockhash` query behavior
 */
/**
 * Configuration object for changing `isBlockhashValid` query behavior
 */
/**
 * Configuration object for changing `getSlot` query behavior
 */
/**
 * Configuration object for changing `getSlotLeader` query behavior
 */
/**
 * Configuration object for changing `getTransaction` query behavior
 */
/**
 * Configuration object for changing `getTransaction` query behavior
 */
/**
 * Configuration object for changing `getLargestAccounts` query behavior
 */
/**
 * Configuration object for changing `getSupply` request behavior
 */
/**
 * Configuration object for changing query behavior
 */
/**
 * Information describing a cluster node
 */
/**
 * Information describing a vote account
 */
/**
 * A collection of cluster vote accounts
 */
/**
 * Network Inflation
 * (see https://docs.solana.com/implemented-proposals/ed_overview)
 */
var GetInflationGovernorResult = type({
  foundation: number(),
  foundationTerm: number(),
  initial: number(),
  taper: number(),
  terminal: number()
});

/**
 * The inflation reward for an epoch
 */

/**
 * Expected JSON RPC response for the "getInflationReward" message
 */
var GetInflationRewardResult = jsonRpcResult(array(nullable(type({
  epoch: number(),
  effectiveSlot: number(),
  amount: number(),
  postBalance: number(),
  commission: optional(nullable(number()))
}))));

/**
 * Configuration object for changing `getRecentPrioritizationFees` query behavior
 */

/**
 * Expected JSON RPC response for the "getRecentPrioritizationFees" message
 */
var GetRecentPrioritizationFeesResult = array(type({
  slot: number(),
  prioritizationFee: number()
}));
/**
 * Expected JSON RPC response for the "getInflationRate" message
 */
var GetInflationRateResult = type({
  total: number(),
  validator: number(),
  foundation: number(),
  epoch: number()
});

/**
 * Information about the current epoch
 */

var GetEpochInfoResult = type({
  epoch: number(),
  slotIndex: number(),
  slotsInEpoch: number(),
  absoluteSlot: number(),
  blockHeight: optional(number()),
  transactionCount: optional(number())
});
var GetEpochScheduleResult = type({
  slotsPerEpoch: number(),
  leaderScheduleSlotOffset: number(),
  warmup: boolean(),
  firstNormalEpoch: number(),
  firstNormalSlot: number()
});

/**
 * Leader schedule
 * (see https://docs.solana.com/terminology#leader-schedule)
 */

var GetLeaderScheduleResult = record(string(), array(number()));

/**
 * Transaction error or null
 */
var TransactionErrorResult = nullable(union([type({}), string()]));

/**
 * Signature status for a transaction
 */
var SignatureStatusResult = type({
  err: TransactionErrorResult
});

/**
 * Transaction signature received notification
 */
var SignatureReceivedResult = literal('receivedSignature');

/**
 * Version info for a node
 */

var VersionResult = type({
  'solana-core': string(),
  'feature-set': optional(number())
});
var SimulatedTransactionResponseStruct = jsonRpcResultAndContext(type({
  err: nullable(union([type({}), string()])),
  logs: nullable(array(string())),
  accounts: optional(nullable(array(nullable(type({
    executable: boolean(),
    owner: string(),
    lamports: number(),
    data: array(string()),
    rentEpoch: optional(number())
  }))))),
  unitsConsumed: optional(number()),
  returnData: optional(nullable(type({
    programId: string(),
    data: tuple([string(), literal('base64')])
  })))
}));

/**
 * Metadata for a parsed confirmed transaction on the ledger
 *
 * @deprecated Deprecated since Solana v1.8.0. Please use {@link ParsedTransactionMeta} instead.
 */

/**
 * Collection of addresses loaded by a transaction using address table lookups
 */

/**
 * Metadata for a parsed transaction on the ledger
 */

/**
 * Metadata for a confirmed transaction on the ledger
 */

/**
 * A processed transaction from the RPC API
 */

/**
 * A processed transaction from the RPC API
 */

/**
 * A processed transaction message from the RPC API
 */

/**
 * A confirmed transaction on the ledger
 *
 * @deprecated Deprecated since Solana v1.8.0.
 */

/**
 * A partially decoded transaction instruction
 */

/**
 * A parsed transaction message account
 */

/**
 * A parsed transaction instruction
 */

/**
 * A parsed address table lookup
 */

/**
 * A parsed transaction message
 */

/**
 * A parsed transaction
 */

/**
 * A parsed and confirmed transaction on the ledger
 *
 * @deprecated Deprecated since Solana v1.8.0. Please use {@link ParsedTransactionWithMeta} instead.
 */

/**
 * A parsed transaction on the ledger with meta
 */

/**
 * A processed block fetched from the RPC API
 */

/**
 * A processed block fetched from the RPC API where the `transactionDetails` mode is `accounts`
 */

/**
 * A processed block fetched from the RPC API where the `transactionDetails` mode is `none`
 */

/**
 * A block with parsed transactions
 */

/**
 * A block with parsed transactions where the `transactionDetails` mode is `accounts`
 */

/**
 * A block with parsed transactions where the `transactionDetails` mode is `none`
 */

/**
 * A processed block fetched from the RPC API
 */

/**
 * A processed block fetched from the RPC API where the `transactionDetails` mode is `accounts`
 */

/**
 * A processed block fetched from the RPC API where the `transactionDetails` mode is `none`
 */

/**
 * A confirmed block on the ledger
 *
 * @deprecated Deprecated since Solana v1.8.0.
 */

/**
 * A Block on the ledger with signatures only
 */

/**
 * recent block production information
 */

/**
 * Expected JSON RPC response for the "getBlockProduction" message
 */
var BlockProductionResponseStruct = jsonRpcResultAndContext(type({
  byIdentity: record(string(), array(number())),
  range: type({
    firstSlot: number(),
    lastSlot: number()
  })
}));

/**
 * A performance sample
 */

function createRpcClient(url, httpHeaders, customFetch, fetchMiddleware, disableRetryOnRateLimit, httpAgent) {
  var fetch = customFetch ? customFetch : fetchImpl;
  var agent;
  {
    if (httpAgent != null) {
      console.warn('You have supplied an `httpAgent` when creating a `Connection` in a browser environment.' + 'It has been ignored; `httpAgent` is only used in Node environments.');
    }
  }
  var fetchWithMiddleware;
  if (fetchMiddleware) {
    fetchWithMiddleware = /*#__PURE__*/function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(info, init) {
        var modifiedFetchArgs;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return new Promise(function (resolve, reject) {
                try {
                  fetchMiddleware(info, init, function (modifiedInfo, modifiedInit) {
                    return resolve([modifiedInfo, modifiedInit]);
                  });
                } catch (error) {
                  reject(error);
                }
              });
            case 2:
              modifiedFetchArgs = _context.sent;
              _context.next = 5;
              return fetch.apply(void 0, _toConsumableArray(modifiedFetchArgs));
            case 5:
              return _context.abrupt("return", _context.sent);
            case 6:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      return function fetchWithMiddleware(_x, _x2) {
        return _ref.apply(this, arguments);
      };
    }();
  }
  var clientBrowser = new RpcClient( /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(request, callback) {
      var options, too_many_requests_retries, res, waitTime, text;
      return _regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            options = {
              method: 'POST',
              body: request,
              agent: agent,
              headers: Object.assign({
                'Content-Type': 'application/json'
              }, httpHeaders || {}, COMMON_HTTP_HEADERS)
            };
            _context2.prev = 1;
            too_many_requests_retries = 5;
            waitTime = 500;
          case 4:
            if (!fetchWithMiddleware) {
              _context2.next = 10;
              break;
            }
            _context2.next = 7;
            return fetchWithMiddleware(url, options);
          case 7:
            res = _context2.sent;
            _context2.next = 13;
            break;
          case 10:
            _context2.next = 12;
            return fetch(url, options);
          case 12:
            res = _context2.sent;
          case 13:
            if (!(res.status !== 429 /* Too many requests */)) {
              _context2.next = 15;
              break;
            }
            return _context2.abrupt("break", 26);
          case 15:
            if (!(disableRetryOnRateLimit === true)) {
              _context2.next = 17;
              break;
            }
            return _context2.abrupt("break", 26);
          case 17:
            too_many_requests_retries -= 1;
            if (!(too_many_requests_retries === 0)) {
              _context2.next = 20;
              break;
            }
            return _context2.abrupt("break", 26);
          case 20:
            console.log("Server responded with ".concat(res.status, " ").concat(res.statusText, ".  Retrying after ").concat(waitTime, "ms delay..."));
            _context2.next = 23;
            return sleep(waitTime);
          case 23:
            waitTime *= 2;
          case 24:
            _context2.next = 4;
            break;
          case 26:
            _context2.next = 28;
            return res.text();
          case 28:
            text = _context2.sent;
            if (res.ok) {
              callback(null, text);
            } else {
              callback(new Error("".concat(res.status, " ").concat(res.statusText, ": ").concat(text)));
            }
            _context2.next = 35;
            break;
          case 32:
            _context2.prev = 32;
            _context2.t0 = _context2["catch"](1);
            if (_context2.t0 instanceof Error) callback(_context2.t0);
          case 35:
          case "end":
            return _context2.stop();
        }
      }, _callee2, null, [[1, 32]]);
    }));
    return function (_x3, _x4) {
      return _ref2.apply(this, arguments);
    };
  }(), {});
  return clientBrowser;
}
function createRpcRequest(client) {
  return function (method, args) {
    return new Promise(function (resolve, reject) {
      client.request(method, args, function (err, response) {
        if (err) {
          reject(err);
          return;
        }
        resolve(response);
      });
    });
  };
}
function createRpcBatchRequest(client) {
  return function (requests) {
    return new Promise(function (resolve, reject) {
      // Do nothing if requests is empty
      if (requests.length === 0) resolve([]);
      var batch = requests.map(function (params) {
        return client.request(params.methodName, params.args);
      });
      client.request(batch, function (err, response) {
        if (err) {
          reject(err);
          return;
        }
        resolve(response);
      });
    });
  };
}

/**
 * Expected JSON RPC response for the "getInflationGovernor" message
 */
var GetInflationGovernorRpcResult = jsonRpcResult(GetInflationGovernorResult);

/**
 * Expected JSON RPC response for the "getInflationRate" message
 */
var GetInflationRateRpcResult = jsonRpcResult(GetInflationRateResult);

/**
 * Expected JSON RPC response for the "getRecentPrioritizationFees" message
 */
var GetRecentPrioritizationFeesRpcResult = jsonRpcResult(GetRecentPrioritizationFeesResult);

/**
 * Expected JSON RPC response for the "getEpochInfo" message
 */
var GetEpochInfoRpcResult = jsonRpcResult(GetEpochInfoResult);

/**
 * Expected JSON RPC response for the "getEpochSchedule" message
 */
var GetEpochScheduleRpcResult = jsonRpcResult(GetEpochScheduleResult);

/**
 * Expected JSON RPC response for the "getLeaderSchedule" message
 */
var GetLeaderScheduleRpcResult = jsonRpcResult(GetLeaderScheduleResult);

/**
 * Expected JSON RPC response for the "minimumLedgerSlot" and "getFirstAvailableBlock" messages
 */
var SlotRpcResult = jsonRpcResult(number());

/**
 * Supply
 */

/**
 * Expected JSON RPC response for the "getSupply" message
 */
var GetSupplyRpcResult = jsonRpcResultAndContext(type({
  total: number(),
  circulating: number(),
  nonCirculating: number(),
  nonCirculatingAccounts: array(PublicKeyFromString)
}));

/**
 * Token amount object which returns a token amount in different formats
 * for various client use cases.
 */

/**
 * Expected JSON RPC structure for token amounts
 */
var TokenAmountResult = type({
  amount: string(),
  uiAmount: nullable(number()),
  decimals: number(),
  uiAmountString: optional(string())
});

/**
 * Token address and balance.
 */

/**
 * Expected JSON RPC response for the "getTokenLargestAccounts" message
 */
var GetTokenLargestAccountsResult = jsonRpcResultAndContext(array(type({
  address: PublicKeyFromString,
  amount: string(),
  uiAmount: nullable(number()),
  decimals: number(),
  uiAmountString: optional(string())
})));

/**
 * Expected JSON RPC response for the "getTokenAccountsByOwner" message
 */
var GetTokenAccountsByOwner = jsonRpcResultAndContext(array(type({
  pubkey: PublicKeyFromString,
  account: type({
    executable: boolean(),
    owner: PublicKeyFromString,
    lamports: number(),
    data: BufferFromRawAccountData,
    rentEpoch: number()
  })
})));
var ParsedAccountDataResult = type({
  program: string(),
  parsed: unknown(),
  space: number()
});

/**
 * Expected JSON RPC response for the "getTokenAccountsByOwner" message with parsed data
 */
var GetParsedTokenAccountsByOwner = jsonRpcResultAndContext(array(type({
  pubkey: PublicKeyFromString,
  account: type({
    executable: boolean(),
    owner: PublicKeyFromString,
    lamports: number(),
    data: ParsedAccountDataResult,
    rentEpoch: number()
  })
})));

/**
 * Pair of an account address and its balance
 */

/**
 * Expected JSON RPC response for the "getLargestAccounts" message
 */
var GetLargestAccountsRpcResult = jsonRpcResultAndContext(array(type({
  lamports: number(),
  address: PublicKeyFromString
})));

/**
 * @internal
 */
var AccountInfoResult = type({
  executable: boolean(),
  owner: PublicKeyFromString,
  lamports: number(),
  data: BufferFromRawAccountData,
  rentEpoch: number()
});

/**
 * @internal
 */
var KeyedAccountInfoResult = type({
  pubkey: PublicKeyFromString,
  account: AccountInfoResult
});
var ParsedOrRawAccountData = coerce(union([instance(Buffer), ParsedAccountDataResult]), union([RawAccountDataResult, ParsedAccountDataResult]), function (value) {
  if (Array.isArray(value)) {
    return create(value, BufferFromRawAccountData);
  } else {
    return value;
  }
});

/**
 * @internal
 */
var ParsedAccountInfoResult = type({
  executable: boolean(),
  owner: PublicKeyFromString,
  lamports: number(),
  data: ParsedOrRawAccountData,
  rentEpoch: number()
});
var KeyedParsedAccountInfoResult = type({
  pubkey: PublicKeyFromString,
  account: ParsedAccountInfoResult
});

/**
 * @internal
 */
var StakeActivationResult = type({
  state: union([literal('active'), literal('inactive'), literal('activating'), literal('deactivating')]),
  active: number(),
  inactive: number()
});

/**
 * Expected JSON RPC response for the "getConfirmedSignaturesForAddress2" message
 */

var GetConfirmedSignaturesForAddress2RpcResult = jsonRpcResult(array(type({
  signature: string(),
  slot: number(),
  err: TransactionErrorResult,
  memo: nullable(string()),
  blockTime: optional(nullable(number()))
})));

/**
 * Expected JSON RPC response for the "getSignaturesForAddress" message
 */
var GetSignaturesForAddressRpcResult = jsonRpcResult(array(type({
  signature: string(),
  slot: number(),
  err: TransactionErrorResult,
  memo: nullable(string()),
  blockTime: optional(nullable(number()))
})));

/***
 * Expected JSON RPC response for the "accountNotification" message
 */
var AccountNotificationResult = type({
  subscription: number(),
  result: notificationResultAndContext(AccountInfoResult)
});

/**
 * @internal
 */
var ProgramAccountInfoResult = type({
  pubkey: PublicKeyFromString,
  account: AccountInfoResult
});

/***
 * Expected JSON RPC response for the "programNotification" message
 */
var ProgramAccountNotificationResult = type({
  subscription: number(),
  result: notificationResultAndContext(ProgramAccountInfoResult)
});

/**
 * @internal
 */
var SlotInfoResult = type({
  parent: number(),
  slot: number(),
  root: number()
});

/**
 * Expected JSON RPC response for the "slotNotification" message
 */
var SlotNotificationResult = type({
  subscription: number(),
  result: SlotInfoResult
});

/**
 * Slot updates which can be used for tracking the live progress of a cluster.
 * - `"firstShredReceived"`: connected node received the first shred of a block.
 * Indicates that a new block that is being produced.
 * - `"completed"`: connected node has received all shreds of a block. Indicates
 * a block was recently produced.
 * - `"optimisticConfirmation"`: block was optimistically confirmed by the
 * cluster. It is not guaranteed that an optimistic confirmation notification
 * will be sent for every finalized blocks.
 * - `"root"`: the connected node rooted this block.
 * - `"createdBank"`: the connected node has started validating this block.
 * - `"frozen"`: the connected node has validated this block.
 * - `"dead"`: the connected node failed to validate this block.
 */

/**
 * @internal
 */
var SlotUpdateResult = union([type({
  type: union([literal('firstShredReceived'), literal('completed'), literal('optimisticConfirmation'), literal('root')]),
  slot: number(),
  timestamp: number()
}), type({
  type: literal('createdBank'),
  parent: number(),
  slot: number(),
  timestamp: number()
}), type({
  type: literal('frozen'),
  slot: number(),
  timestamp: number(),
  stats: type({
    numTransactionEntries: number(),
    numSuccessfulTransactions: number(),
    numFailedTransactions: number(),
    maxTransactionsPerEntry: number()
  })
}), type({
  type: literal('dead'),
  slot: number(),
  timestamp: number(),
  err: string()
})]);

/**
 * Expected JSON RPC response for the "slotsUpdatesNotification" message
 */
var SlotUpdateNotificationResult = type({
  subscription: number(),
  result: SlotUpdateResult
});

/**
 * Expected JSON RPC response for the "signatureNotification" message
 */
var SignatureNotificationResult = type({
  subscription: number(),
  result: notificationResultAndContext(union([SignatureStatusResult, SignatureReceivedResult]))
});

/**
 * Expected JSON RPC response for the "rootNotification" message
 */
var RootNotificationResult = type({
  subscription: number(),
  result: number()
});
var ContactInfoResult = type({
  pubkey: string(),
  gossip: nullable(string()),
  tpu: nullable(string()),
  rpc: nullable(string()),
  version: nullable(string())
});
var VoteAccountInfoResult = type({
  votePubkey: string(),
  nodePubkey: string(),
  activatedStake: number(),
  epochVoteAccount: boolean(),
  epochCredits: array(tuple([number(), number(), number()])),
  commission: number(),
  lastVote: number(),
  rootSlot: nullable(number())
});

/**
 * Expected JSON RPC response for the "getVoteAccounts" message
 */
var GetVoteAccounts = jsonRpcResult(type({
  current: array(VoteAccountInfoResult),
  delinquent: array(VoteAccountInfoResult)
}));
var ConfirmationStatus = union([literal('processed'), literal('confirmed'), literal('finalized')]);
var SignatureStatusResponse = type({
  slot: number(),
  confirmations: nullable(number()),
  err: TransactionErrorResult,
  confirmationStatus: optional(ConfirmationStatus)
});

/**
 * Expected JSON RPC response for the "getSignatureStatuses" message
 */
var GetSignatureStatusesRpcResult = jsonRpcResultAndContext(array(nullable(SignatureStatusResponse)));

/**
 * Expected JSON RPC response for the "getMinimumBalanceForRentExemption" message
 */
var GetMinimumBalanceForRentExemptionRpcResult = jsonRpcResult(number());
var AddressTableLookupStruct = type({
  accountKey: PublicKeyFromString,
  writableIndexes: array(number()),
  readonlyIndexes: array(number())
});
var ConfirmedTransactionResult = type({
  signatures: array(string()),
  message: type({
    accountKeys: array(string()),
    header: type({
      numRequiredSignatures: number(),
      numReadonlySignedAccounts: number(),
      numReadonlyUnsignedAccounts: number()
    }),
    instructions: array(type({
      accounts: array(number()),
      data: string(),
      programIdIndex: number()
    })),
    recentBlockhash: string(),
    addressTableLookups: optional(array(AddressTableLookupStruct))
  })
});
var AnnotatedAccountKey = type({
  pubkey: PublicKeyFromString,
  signer: boolean(),
  writable: boolean(),
  source: optional(union([literal('transaction'), literal('lookupTable')]))
});
var ConfirmedTransactionAccountsModeResult = type({
  accountKeys: array(AnnotatedAccountKey),
  signatures: array(string())
});
var ParsedInstructionResult = type({
  parsed: unknown(),
  program: string(),
  programId: PublicKeyFromString
});
var RawInstructionResult = type({
  accounts: array(PublicKeyFromString),
  data: string(),
  programId: PublicKeyFromString
});
var InstructionResult = union([RawInstructionResult, ParsedInstructionResult]);
var UnknownInstructionResult = union([type({
  parsed: unknown(),
  program: string(),
  programId: string()
}), type({
  accounts: array(string()),
  data: string(),
  programId: string()
})]);
var ParsedOrRawInstruction = coerce(InstructionResult, UnknownInstructionResult, function (value) {
  if ('accounts' in value) {
    return create(value, RawInstructionResult);
  } else {
    return create(value, ParsedInstructionResult);
  }
});

/**
 * @internal
 */
var ParsedConfirmedTransactionResult = type({
  signatures: array(string()),
  message: type({
    accountKeys: array(AnnotatedAccountKey),
    instructions: array(ParsedOrRawInstruction),
    recentBlockhash: string(),
    addressTableLookups: optional(nullable(array(AddressTableLookupStruct)))
  })
});
var TokenBalanceResult = type({
  accountIndex: number(),
  mint: string(),
  owner: optional(string()),
  uiTokenAmount: TokenAmountResult
});
var LoadedAddressesResult = type({
  writable: array(PublicKeyFromString),
  readonly: array(PublicKeyFromString)
});

/**
 * @internal
 */
var ConfirmedTransactionMetaResult = type({
  err: TransactionErrorResult,
  fee: number(),
  innerInstructions: optional(nullable(array(type({
    index: number(),
    instructions: array(type({
      accounts: array(number()),
      data: string(),
      programIdIndex: number()
    }))
  })))),
  preBalances: array(number()),
  postBalances: array(number()),
  logMessages: optional(nullable(array(string()))),
  preTokenBalances: optional(nullable(array(TokenBalanceResult))),
  postTokenBalances: optional(nullable(array(TokenBalanceResult))),
  loadedAddresses: optional(LoadedAddressesResult),
  computeUnitsConsumed: optional(number())
});

/**
 * @internal
 */
var ParsedConfirmedTransactionMetaResult = type({
  err: TransactionErrorResult,
  fee: number(),
  innerInstructions: optional(nullable(array(type({
    index: number(),
    instructions: array(ParsedOrRawInstruction)
  })))),
  preBalances: array(number()),
  postBalances: array(number()),
  logMessages: optional(nullable(array(string()))),
  preTokenBalances: optional(nullable(array(TokenBalanceResult))),
  postTokenBalances: optional(nullable(array(TokenBalanceResult))),
  loadedAddresses: optional(LoadedAddressesResult),
  computeUnitsConsumed: optional(number())
});
var TransactionVersionStruct = union([literal(0), literal('legacy')]);

/** @internal */
var RewardsResult = type({
  pubkey: string(),
  lamports: number(),
  postBalance: nullable(number()),
  rewardType: nullable(string()),
  commission: optional(nullable(number()))
});

/**
 * Expected JSON RPC response for the "getBlock" message
 */
var GetBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ConfirmedTransactionResult,
    meta: nullable(ConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
})));

/**
 * Expected JSON RPC response for the "getBlock" message when `transactionDetails` is `none`
 */
var GetNoneModeBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
})));

/**
 * Expected JSON RPC response for the "getBlock" message when `transactionDetails` is `accounts`
 */
var GetAccountsModeBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ConfirmedTransactionAccountsModeResult,
    meta: nullable(ConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
})));

/**
 * Expected parsed JSON RPC response for the "getBlock" message
 */
var GetParsedBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ParsedConfirmedTransactionResult,
    meta: nullable(ParsedConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
})));

/**
 * Expected parsed JSON RPC response for the "getBlock" message  when `transactionDetails` is `accounts`
 */
var GetParsedAccountsModeBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ConfirmedTransactionAccountsModeResult,
    meta: nullable(ParsedConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
})));

/**
 * Expected parsed JSON RPC response for the "getBlock" message  when `transactionDetails` is `none`
 */
var GetParsedNoneModeBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
})));

/**
 * Expected JSON RPC response for the "getConfirmedBlock" message
 *
 * @deprecated Deprecated since Solana v1.8.0. Please use {@link GetBlockRpcResult} instead.
 */
var GetConfirmedBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ConfirmedTransactionResult,
    meta: nullable(ConfirmedTransactionMetaResult)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number())
})));

/**
 * Expected JSON RPC response for the "getBlock" message
 */
var GetBlockSignaturesRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  signatures: array(string()),
  blockTime: nullable(number())
})));

/**
 * Expected JSON RPC response for the "getTransaction" message
 */
var GetTransactionRpcResult = jsonRpcResult(nullable(type({
  slot: number(),
  meta: ConfirmedTransactionMetaResult,
  blockTime: optional(nullable(number())),
  transaction: ConfirmedTransactionResult,
  version: optional(TransactionVersionStruct)
})));

/**
 * Expected parsed JSON RPC response for the "getTransaction" message
 */
var GetParsedTransactionRpcResult = jsonRpcResult(nullable(type({
  slot: number(),
  transaction: ParsedConfirmedTransactionResult,
  meta: nullable(ParsedConfirmedTransactionMetaResult),
  blockTime: optional(nullable(number())),
  version: optional(TransactionVersionStruct)
})));

/**
 * Expected JSON RPC response for the "getRecentBlockhash" message
 *
 * @deprecated Deprecated since Solana v1.8.0. Please use {@link GetLatestBlockhashRpcResult} instead.
 */
var GetRecentBlockhashAndContextRpcResult = jsonRpcResultAndContext(type({
  blockhash: string(),
  feeCalculator: type({
    lamportsPerSignature: number()
  })
}));

/**
 * Expected JSON RPC response for the "getLatestBlockhash" message
 */
var GetLatestBlockhashRpcResult = jsonRpcResultAndContext(type({
  blockhash: string(),
  lastValidBlockHeight: number()
}));

/**
 * Expected JSON RPC response for the "isBlockhashValid" message
 */
var IsBlockhashValidRpcResult = jsonRpcResultAndContext(boolean());
var PerfSampleResult = type({
  slot: number(),
  numTransactions: number(),
  numSlots: number(),
  samplePeriodSecs: number()
});

/*
 * Expected JSON RPC response for "getRecentPerformanceSamples" message
 */
var GetRecentPerformanceSamplesRpcResult = jsonRpcResult(array(PerfSampleResult));

/**
 * Expected JSON RPC response for the "getFeeCalculatorForBlockhash" message
 */
var GetFeeCalculatorRpcResult = jsonRpcResultAndContext(nullable(type({
  feeCalculator: type({
    lamportsPerSignature: number()
  })
})));

/**
 * Expected JSON RPC response for the "requestAirdrop" message
 */
var RequestAirdropRpcResult = jsonRpcResult(string());

/**
 * Expected JSON RPC response for the "sendTransaction" message
 */
var SendTransactionRpcResult = jsonRpcResult(string());

/**
 * Information about the latest slot being processed by a node
 */

/**
 * Parsed account data
 */

/**
 * Stake Activation data
 */

/**
 * Data slice argument for getProgramAccounts
 */

/**
 * Memory comparison filter for getProgramAccounts
 */

/**
 * Data size comparison filter for getProgramAccounts
 */

/**
 * A filter object for getProgramAccounts
 */

/**
 * Configuration object for getProgramAccounts requests
 */

/**
 * Configuration object for getParsedProgramAccounts
 */

/**
 * Configuration object for getMultipleAccounts
 */

/**
 * Configuration object for `getStakeActivation`
 */

/**
 * Configuration object for `getStakeActivation`
 */

/**
 * Configuration object for `getStakeActivation`
 */

/**
 * Configuration object for `getNonce`
 */

/**
 * Configuration object for `getNonceAndContext`
 */

/**
 * Information describing an account
 */

/**
 * Account information identified by pubkey
 */

/**
 * Callback function for account change notifications
 */

/**
 * Callback function for program account change notifications
 */

/**
 * Callback function for slot change notifications
 */

/**
 * Callback function for slot update notifications
 */

/**
 * Callback function for signature status notifications
 */

/**
 * Signature status notification with transaction result
 */

/**
 * Signature received notification
 */

/**
 * Callback function for signature notifications
 */

/**
 * Signature subscription options
 */

/**
 * Callback function for root change notifications
 */

/**
 * @internal
 */
var LogsResult = type({
  err: TransactionErrorResult,
  logs: array(string()),
  signature: string()
});

/**
 * Logs result.
 */

/**
 * Expected JSON RPC response for the "logsNotification" message.
 */
var LogsNotificationResult = type({
  result: notificationResultAndContext(LogsResult),
  subscription: number()
});

/**
 * Filter for log subscriptions.
 */

/**
 * Callback function for log notifications.
 */

/**
 * Signature result
 */

/**
 * Transaction error
 */

/**
 * Transaction confirmation status
 * <pre>
 *   'processed': Transaction landed in a block which has reached 1 confirmation by the connected node
 *   'confirmed': Transaction landed in a block which has reached 1 confirmation by the cluster
 *   'finalized': Transaction landed in a block which has been finalized by the cluster
 * </pre>
 */

/**
 * Signature status
 */

/**
 * A confirmed signature with its status
 */

/**
 * An object defining headers to be passed to the RPC server
 */

/**
 * The type of the JavaScript `fetch()` API
 */

/**
 * A callback used to augment the outgoing HTTP request
 */

/**
 * Configuration for instantiating a Connection
 */

/** @internal */
var COMMON_HTTP_HEADERS = {
  'solana-client': "js/".concat((_process$env$npm_pack = "0.0.0-development") !== null && _process$env$npm_pack !== void 0 ? _process$env$npm_pack : 'UNKNOWN')
};

/**
 * A connection to a fullnode JSON RPC endpoint
 */
var Connection = /*#__PURE__*/function () {
  /**
   * Establish a JSON RPC connection
   *
   * @param endpoint URL to the fullnode JSON RPC endpoint
   * @param commitmentOrConfig optional default commitment level or optional ConnectionConfig configuration object
   */
  function Connection(endpoint, _commitmentOrConfig) {
    var _this = this;
    _classCallCheck(this, Connection);
    /** @internal */
    this._commitment = void 0;
    /** @internal */
    this._confirmTransactionInitialTimeout = void 0;
    /** @internal */
    this._rpcEndpoint = void 0;
    /** @internal */
    this._rpcWsEndpoint = void 0;
    /** @internal */
    this._rpcClient = void 0;
    /** @internal */
    this._rpcRequest = void 0;
    /** @internal */
    this._rpcBatchRequest = void 0;
    /** @internal */
    this._rpcWebSocket = void 0;
    /** @internal */
    this._rpcWebSocketConnected = false;
    /** @internal */
    this._rpcWebSocketHeartbeat = null;
    /** @internal */
    this._rpcWebSocketIdleTimeout = null;
    /** @internal
     * A number that we increment every time an active connection closes.
     * Used to determine whether the same socket connection that was open
     * when an async operation started is the same one that's active when
     * its continuation fires.
     *
     */
    this._rpcWebSocketGeneration = 0;
    /** @internal */
    this._disableBlockhashCaching = false;
    /** @internal */
    this._pollingBlockhash = false;
    /** @internal */
    this._blockhashInfo = {
      latestBlockhash: null,
      lastFetch: 0,
      transactionSignatures: [],
      simulatedSignatures: []
    };
    /** @internal */
    this._nextClientSubscriptionId = 0;
    /** @internal */
    this._subscriptionDisposeFunctionsByClientSubscriptionId = {};
    /** @internal */
    this._subscriptionHashByClientSubscriptionId = {};
    /** @internal */
    this._subscriptionStateChangeCallbacksByHash = {};
    /** @internal */
    this._subscriptionCallbacksByServerSubscriptionId = {};
    /** @internal */
    this._subscriptionsByHash = {};
    /**
     * Special case.
     * After a signature is processed, RPCs automatically dispose of the
     * subscription on the server side. We need to track which of these
     * subscriptions have been disposed in such a way, so that we know
     * whether the client is dealing with a not-yet-processed signature
     * (in which case we must tear down the server subscription) or an
     * already-processed signature (in which case the client can simply
     * clear out the subscription locally without telling the server).
     *
     * NOTE: There is a proposal to eliminate this special case, here:
     * https://github.com/solana-labs/solana/issues/18892
     */
    /** @internal */
    this._subscriptionsAutoDisposedByRpc = new Set();
    /*
     * Returns the current block height of the node
     */
    this.getBlockHeight = function () {
      var requestPromises = {};
      return /*#__PURE__*/function () {
        var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(commitmentOrConfig) {
          var _requestPromises$requ;
          var _extractCommitmentFro, commitment, config, args, requestHash;
          return _regeneratorRuntime.wrap(function _callee4$(_context4) {
            while (1) switch (_context4.prev = _context4.next) {
              case 0:
                _extractCommitmentFro = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro.commitment, config = _extractCommitmentFro.config;
                args = _this._buildArgs([], commitment, undefined /* encoding */, config);
                requestHash = fastStableStringify$1(args);
                requestPromises[requestHash] = (_requestPromises$requ = requestPromises[requestHash]) !== null && _requestPromises$requ !== void 0 ? _requestPromises$requ : _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {
                  var unsafeRes, res;
                  return _regeneratorRuntime.wrap(function _callee3$(_context3) {
                    while (1) switch (_context3.prev = _context3.next) {
                      case 0:
                        _context3.prev = 0;
                        _context3.next = 3;
                        return _this._rpcRequest('getBlockHeight', args);
                      case 3:
                        unsafeRes = _context3.sent;
                        res = create(unsafeRes, jsonRpcResult(number()));
                        if (!('error' in res)) {
                          _context3.next = 7;
                          break;
                        }
                        throw new SolanaJSONRPCError(res.error, 'failed to get block height information');
                      case 7:
                        return _context3.abrupt("return", res.result);
                      case 8:
                        _context3.prev = 8;
                        delete requestPromises[requestHash];
                        return _context3.finish(8);
                      case 11:
                      case "end":
                        return _context3.stop();
                    }
                  }, _callee3, null, [[0,, 8, 11]]);
                }))();
                _context4.next = 6;
                return requestPromises[requestHash];
              case 6:
                return _context4.abrupt("return", _context4.sent);
              case 7:
              case "end":
                return _context4.stop();
            }
          }, _callee4);
        }));
        return function (_x5) {
          return _ref3.apply(this, arguments);
        };
      }();
    }();
    var wsEndpoint;
    var httpHeaders;
    var fetch;
    var fetchMiddleware;
    var disableRetryOnRateLimit;
    var httpAgent;
    if (_commitmentOrConfig && typeof _commitmentOrConfig === 'string') {
      this._commitment = _commitmentOrConfig;
    } else if (_commitmentOrConfig) {
      this._commitment = _commitmentOrConfig.commitment;
      this._confirmTransactionInitialTimeout = _commitmentOrConfig.confirmTransactionInitialTimeout;
      wsEndpoint = _commitmentOrConfig.wsEndpoint;
      httpHeaders = _commitmentOrConfig.httpHeaders;
      fetch = _commitmentOrConfig.fetch;
      fetchMiddleware = _commitmentOrConfig.fetchMiddleware;
      disableRetryOnRateLimit = _commitmentOrConfig.disableRetryOnRateLimit;
      httpAgent = _commitmentOrConfig.httpAgent;
    }
    this._rpcEndpoint = assertEndpointUrl(endpoint);
    this._rpcWsEndpoint = wsEndpoint || makeWebsocketUrl(endpoint);
    this._rpcClient = createRpcClient(endpoint, httpHeaders, fetch, fetchMiddleware, disableRetryOnRateLimit, httpAgent);
    this._rpcRequest = createRpcRequest(this._rpcClient);
    this._rpcBatchRequest = createRpcBatchRequest(this._rpcClient);
    this._rpcWebSocket = new RpcWebSocketClient(this._rpcWsEndpoint, {
      autoconnect: false,
      max_reconnects: Infinity
    });
    this._rpcWebSocket.on('open', this._wsOnOpen.bind(this));
    this._rpcWebSocket.on('error', this._wsOnError.bind(this));
    this._rpcWebSocket.on('close', this._wsOnClose.bind(this));
    this._rpcWebSocket.on('accountNotification', this._wsOnAccountNotification.bind(this));
    this._rpcWebSocket.on('programNotification', this._wsOnProgramAccountNotification.bind(this));
    this._rpcWebSocket.on('slotNotification', this._wsOnSlotNotification.bind(this));
    this._rpcWebSocket.on('slotsUpdatesNotification', this._wsOnSlotUpdatesNotification.bind(this));
    this._rpcWebSocket.on('signatureNotification', this._wsOnSignatureNotification.bind(this));
    this._rpcWebSocket.on('rootNotification', this._wsOnRootNotification.bind(this));
    this._rpcWebSocket.on('logsNotification', this._wsOnLogsNotification.bind(this));
  }

  /**
   * The default commitment used for requests
   */
  _createClass(Connection, [{
    key: "commitment",
    get: function get() {
      return this._commitment;
    }

    /**
     * The RPC endpoint
     */
  }, {
    key: "rpcEndpoint",
    get: function get() {
      return this._rpcEndpoint;
    }

    /**
     * Fetch the balance for the specified public key, return with context
     */
  }, {
    key: "getBalanceAndContext",
    value: function () {
      var _getBalanceAndContext = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(publicKey, commitmentOrConfig) {
        var _extractCommitmentFro2, commitment, config, args, unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              /** @internal */
              _extractCommitmentFro2 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro2.commitment, config = _extractCommitmentFro2.config;
              args = this._buildArgs([publicKey.toBase58()], commitment, undefined /* encoding */, config);
              _context5.next = 4;
              return this._rpcRequest('getBalance', args);
            case 4:
              unsafeRes = _context5.sent;
              res = create(unsafeRes, jsonRpcResultAndContext(number()));
              if (!('error' in res)) {
                _context5.next = 8;
                break;
              }
              throw new SolanaJSONRPCError(res.error, "failed to get balance for ".concat(publicKey.toBase58()));
            case 8:
              return _context5.abrupt("return", res.result);
            case 9:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function getBalanceAndContext(_x6, _x7) {
        return _getBalanceAndContext.apply(this, arguments);
      }
      return getBalanceAndContext;
    }()
    /**
     * Fetch the balance for the specified public key
     */
  }, {
    key: "getBalance",
    value: function () {
      var _getBalance = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(publicKey, commitmentOrConfig) {
        return _regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              _context6.next = 2;
              return this.getBalanceAndContext(publicKey, commitmentOrConfig).then(function (x) {
                return x.value;
              })["catch"](function (e) {
                throw new Error('failed to get balance of account ' + publicKey.toBase58() + ': ' + e);
              });
            case 2:
              return _context6.abrupt("return", _context6.sent);
            case 3:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function getBalance(_x8, _x9) {
        return _getBalance.apply(this, arguments);
      }
      return getBalance;
    }()
    /**
     * Fetch the estimated production time of a block
     */
  }, {
    key: "getBlockTime",
    value: function () {
      var _getBlockTime = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(slot) {
        var unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              _context7.next = 2;
              return this._rpcRequest('getBlockTime', [slot]);
            case 2:
              unsafeRes = _context7.sent;
              res = create(unsafeRes, jsonRpcResult(nullable(number())));
              if (!('error' in res)) {
                _context7.next = 6;
                break;
              }
              throw new SolanaJSONRPCError(res.error, "failed to get block time for slot ".concat(slot));
            case 6:
              return _context7.abrupt("return", res.result);
            case 7:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this);
      }));
      function getBlockTime(_x10) {
        return _getBlockTime.apply(this, arguments);
      }
      return getBlockTime;
    }()
    /**
     * Fetch the lowest slot that the node has information about in its ledger.
     * This value may increase over time if the node is configured to purge older ledger data
     */
  }, {
    key: "getMinimumLedgerSlot",
    value: function () {
      var _getMinimumLedgerSlot = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {
        var unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              _context8.next = 2;
              return this._rpcRequest('minimumLedgerSlot', []);
            case 2:
              unsafeRes = _context8.sent;
              res = create(unsafeRes, jsonRpcResult(number()));
              if (!('error' in res)) {
                _context8.next = 6;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get minimum ledger slot');
            case 6:
              return _context8.abrupt("return", res.result);
            case 7:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this);
      }));
      function getMinimumLedgerSlot() {
        return _getMinimumLedgerSlot.apply(this, arguments);
      }
      return getMinimumLedgerSlot;
    }()
    /**
     * Fetch the slot of the lowest confirmed block that has not been purged from the ledger
     */
  }, {
    key: "getFirstAvailableBlock",
    value: function () {
      var _getFirstAvailableBlock = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {
        var unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              _context9.next = 2;
              return this._rpcRequest('getFirstAvailableBlock', []);
            case 2:
              unsafeRes = _context9.sent;
              res = create(unsafeRes, SlotRpcResult);
              if (!('error' in res)) {
                _context9.next = 6;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get first available block');
            case 6:
              return _context9.abrupt("return", res.result);
            case 7:
            case "end":
              return _context9.stop();
          }
        }, _callee9, this);
      }));
      function getFirstAvailableBlock() {
        return _getFirstAvailableBlock.apply(this, arguments);
      }
      return getFirstAvailableBlock;
    }()
    /**
     * Fetch information about the current supply
     */
  }, {
    key: "getSupply",
    value: function () {
      var _getSupply = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(config) {
        var configArg, unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              configArg = {};
              if (typeof config === 'string') {
                configArg = {
                  commitment: config
                };
              } else if (config) {
                configArg = _objectSpread(_objectSpread({}, config), {}, {
                  commitment: config && config.commitment || this.commitment
                });
              } else {
                configArg = {
                  commitment: this.commitment
                };
              }
              _context10.next = 4;
              return this._rpcRequest('getSupply', [configArg]);
            case 4:
              unsafeRes = _context10.sent;
              res = create(unsafeRes, GetSupplyRpcResult);
              if (!('error' in res)) {
                _context10.next = 8;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get supply');
            case 8:
              return _context10.abrupt("return", res.result);
            case 9:
            case "end":
              return _context10.stop();
          }
        }, _callee10, this);
      }));
      function getSupply(_x11) {
        return _getSupply.apply(this, arguments);
      }
      return getSupply;
    }()
    /**
     * Fetch the current supply of a token mint
     */
  }, {
    key: "getTokenSupply",
    value: function () {
      var _getTokenSupply = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(tokenMintAddress, commitment) {
        var args, unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              args = this._buildArgs([tokenMintAddress.toBase58()], commitment);
              _context11.next = 3;
              return this._rpcRequest('getTokenSupply', args);
            case 3:
              unsafeRes = _context11.sent;
              res = create(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));
              if (!('error' in res)) {
                _context11.next = 7;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get token supply');
            case 7:
              return _context11.abrupt("return", res.result);
            case 8:
            case "end":
              return _context11.stop();
          }
        }, _callee11, this);
      }));
      function getTokenSupply(_x12, _x13) {
        return _getTokenSupply.apply(this, arguments);
      }
      return getTokenSupply;
    }()
    /**
     * Fetch the current balance of a token account
     */
  }, {
    key: "getTokenAccountBalance",
    value: function () {
      var _getTokenAccountBalance = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12(tokenAddress, commitment) {
        var args, unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) switch (_context12.prev = _context12.next) {
            case 0:
              args = this._buildArgs([tokenAddress.toBase58()], commitment);
              _context12.next = 3;
              return this._rpcRequest('getTokenAccountBalance', args);
            case 3:
              unsafeRes = _context12.sent;
              res = create(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));
              if (!('error' in res)) {
                _context12.next = 7;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get token account balance');
            case 7:
              return _context12.abrupt("return", res.result);
            case 8:
            case "end":
              return _context12.